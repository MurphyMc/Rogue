#------------------------------------------------------------------------------
# Program
#------------------------------------------------------------------------------
augment Program
  METHODS
    method validate_cpp_name( name:String )->String
      local begins_with_code_prefix = false
      if (name.begins_with(code_prefix))
        begins_with_code_prefix = true
        name = name.from( code_prefix.count )
      endIf

      # Convert "_*type" to "__*type"
      local all_underscores = true
      if (name.ends_with("type"))
        forEach (i in 0..(name.count-5))
          if (name[i] != '_') all_underscores = false; escapeForEach
        endForEach
        name = "_" + name
      endIf

      # Type? -> OptionalType
      local i1 = name.locate('?')
      while (i1?)
        name = "Optional" + name.leftmost(i1.value) + name.from(i1.value+1)
        i1 = name.locate('?')
      endWhile

      # Convert ABC->XYZ to ABCRETURNSXYZ
      i1 = name.locate( "->" )
      while (i1?)
        name = "$RETURNS$" (name.leftmost(i1.value),name.from(i1.value+2))
        i1 = name.locate( "->" )
      endWhile

      # Type<<Specialization>> -> Type_Specialization_
      i1 = name.locate("<<")
      while (i1?)
        local i2 = locate_matching_close_specialize( name, i1 )
        if (not i2?) escapeWhile

        local before = name.from(0,i1.value-1)
        local after  = name.from(i2.value+2)
        local middle = name.from(i1.value+2,i2.value-1)

        name = "$_$_$" (before,middle,after)

        i1 = name.locate("<<")
      endWhile

      #   Table_of_String,Int32[] -> Table_of_String,Int32_List
      i1 = name.locate("[]")
      while (i1?)
        name = "$_List$" (name.from(0,i1.value-1),name.from(i1.value+2))
        i1 = name.locate("[]")
      endWhile

      string_buffer.clear
      if (begins_with_code_prefix) string_buffer.print( Program.code_prefix )

      local count = name.count
      forEach (i of name)
        local ch = name[i]
        if (ch.is_alphanumeric or ch == '$')
          string_buffer.print( ch )
        else
          which (ch)
            case '!': string_buffer.print( "NOT" )
            case '%': string_buffer.print( "MOD" )
            case '&': string_buffer.print( "AND" )
            case '*': string_buffer.print( "TIMES" )
            case '+': string_buffer.print( "PLUS" )
            case '-'
              if (i+1 < name.count)
                which (name[i+1])
                  case '>'
                    string_buffer.print( "RETURNS" )
                    ++i
                  others
                    string_buffer.print( "MINUS" )
                endWhich
              endIf
            case '.': string_buffer.print( "_" )
            case '/': string_buffer.print( "SLASH" )
            case '<'
              if (i+1 < name.count)
                which (name[i+1])
                  case '='
                    string_buffer.print( "LE" )
                    ++i
                  others
                    string_buffer.print( "LT" )
                endWhich
              endIf
            case '=': string_buffer.print( "EQUALS" )
            case '>'
              if (i+1 < name.count)
                which (name[i+1])
                  case '='
                    string_buffer.print( "GE" )
                    ++i
                  others
                    string_buffer.print( "GT" )
                endWhich
              endIf
            case '^': string_buffer.print( "POWER" )
            case '|': string_buffer.print( "OR" )
            case '~': string_buffer.print( "XOR" )
            others:   string_buffer.print( '_' )
          endWhich
        endIf
      endForEach

      return string_buffer->String

    method locate_matching_close_specialize( st:String, i1:Int32? )->Int32?
      local nesting_level = 1
      forEach (i in i1.value+2..st.count-2)
        if (st[i] == '<' and st[i+1] == '<')
          ++nesting_level
          ++i
        elseIf (st[i] == '>' and st[i+1] == '>')
          --nesting_level
          if (nesting_level == 0) return i
          ++i
        endIf
      endForEach
      return null

    method write_cpp( filepath:String )
      forEach (type in type_list)
        type.assign_cpp_name
      endForEach
      type_NativeArray.cpp_class_name = "RogueArray"

      forEach (type in type_list)
        forEach (r in type.global_method_list) r.assign_cpp_name
        forEach (m in type.method_list)  m.assign_cpp_name
      endForEach

      # .H header -------------------------------------------------------------
      println "Writing $.h..." (filepath)
      local writer = CPPWriter( filepath + ".h" )

      # Header
      writer.println "//-----------------------------------------------------------------------------"
      writer.println "//  Generated by the Rogue compiler"
      writer.println "//-----------------------------------------------------------------------------"
      writer.println "#pragma once"

      forEach (plugin in RogueC.plugins)
        plugin.start_header_file( writer )
      endForEach

      # It'd be nice to be able to override these with a C++ -D arg...
      writer.print "#define ROGUE_GC_MODE_MANUAL "
      writer.println select{RogueC.gc_mode == GCMode.MANUAL: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_AUTO "
      writer.println select{RogueC.gc_mode == GCMode.AUTO: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_BOEHM "
      writer.println select{RogueC.gc_mode == GCMode.BOEHM: "1" || "0"}
      writer.println

      # GC Threshold
      writer.println "#ifndef ROGUE_GC_THRESHOLD_DEFAULT"
      writer.print(  "  #define ROGUE_GC_THRESHOLD_DEFAULT " ).println( RogueC.gc_threshold )
      writer.println "#endif"
      writer.println

      # Embed nativeHeader
      writer.println "// NATIVE HEADERS"
      forEach (line in native_header)
        writer.println( line )
      endForEach

      writer.println "#include <cmath>"
      writer.println

      # RogueObject forward declarations
      writer.println "// FORWARD DECLARATIONS"
      forEach (type in type_list)
        if (not type.omit_output and not type.is_primitive)
          writer.print( "struct " ).print( type.cpp_class_name ).print("; // ").println( type.name )
        endIf
      endForEach
      writer.println

      # Compound definitions
      writer.println "// COMPOUND DEFINITIONS"
      forEach (type in type_list)
        if (type.is_compound and not type.omit_output)
          type.print_data_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # Global externs
      writer.println "// GLOBAL PROPERTIES"
      forEach (type in type_list)
        forEach (g in type.global_list)
          writer.print( "extern " ).print( g.type ).print( " Rogue" )
          writer.print( type.cpp_name ).print( "_" ).print( g.cpp_name ).println( ";" )
        endForEach
      endForEach
      writer.println

      # Class definitions
      writer.println "// CLASS DEFINITIONS"
      forEach (type in type_list)
        if (not type.is_compound and not type.omit_output)
          type.print_data_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # RogueType_X externs.
      writer.println "// ROGUE TYPES"
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print( "extern RogueType* RogueType" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      # Routine prototypes
      writer.println "// ROUTINE PROTOTYPES"
      forEach (type in type_list) type.print_global_method_prototypes( writer )
      writer.println

      # Method prototypes
      writer.println "// METHOD PROTOTYPES"
      forEach (type in type_list) type.print_method_prototypes( writer )
      writer.println

      # Trace routine prototype
      writer.println "// INTERNAL PROTOTYPES"
      writer.println( "void Rogue_trace();" )
      writer.println

      # typedef each unique method signature
      local native_method_signature_list   = String[]
      local native_method_signature_lookup = Table<<String,Method>>()
      forEach (type in type_list)
        if (type.is_used)
          type.determine_cpp_method_typedefs( native_method_signature_list, native_method_signature_lookup )
        endIf
      endForEach

      # write dynamic dispatch method prototypes
      if (RogueC.all_methods_callable_dynamically)
        forEach (sig in native_method_signature_list)
          local m = native_method_signature_lookup[sig]  # one of the methods using this signature
          if (m.called_dynamically or RogueC.all_methods_callable_dynamically)
            writer.print( "extern ").print( m.return_type ).print( " Rogue_call_" ).print( m.cpp_typedef )
            writer.print( "( int i, " ).print( m.type_context ).print( " THIS" )
            forEach (i of m.parameters)
              local p = m.parameters[i]
              writer.print( ", " ).print(p.type).print( " p" ).print( i )
            endForEach
            writer.println( " );" )
          endIf
        endForEach
        writer.println
      endIf

      forEach (plugin in RogueC.plugins)
        plugin.finish_header_file( writer )
      endForEach

      writer.close

      # .CPP implementation ---------------------------------------------------
      println "Writing $.cpp..." (filepath)
      writer = CPPWriter( filepath + ".cpp" )

      local base_filename = filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println "#include <stdio.h>"
      writer.println ''#include "$.h"'' (base_filename)
      writer.println

      # Embed nativeCode
      forEach (line in native_code)
        writer.println( line )
      endForEach

      forEach (plugin in RogueC.plugins)
        plugin.start_code_file( writer )
      endForEach

      forEach (sig in native_method_signature_list)
        writer.print( "typedef " ).print( sig.before_first("(*)") ).print( "(*" )
        writer.print( native_method_signature_lookup[sig].cpp_typedef ).print(")")
        writer.print( sig.after_first("(*)") ).println( ";" )
      endForEach
      writer.println

      # write dynamic dipatch methods
      forEach (sig in native_method_signature_list)
        local m = native_method_signature_lookup[sig]  # one of the methods using this signature
        if (m.called_dynamically or RogueC.all_methods_callable_dynamically)
          writer.print( m.return_type ).print( " Rogue_call_" ).print( m.cpp_typedef )
          writer.print( "( int i, " ).print( m.type_context ).print( " THIS" )
          forEach (i of m.parameters)
            local p = m.parameters[i]
            writer.print( ", " ).print(p.type).print( " p" ).print( i )
          endForEach
          writer.println( " )" )
          writer.println( "{" )
          writer.print( "  " )
          if (m.return_type) writer.print( "return " )
          writer.print( "((" ).print( m.cpp_typedef )
          writer.print( ")(THIS->type->methods[i]))( THIS" )
          forEach (i of m.parameters)
            writer.print( ", p" ).print( i )
          endForEach
          writer.println( " );" )
          writer.println( "}" )
          writer.println
        endIf
      endForEach
      writer.println

      # Global declarations
      writer.println "// GLOBAL PROPERTIES"
      forEach (type in type_list)
        forEach (g in type.global_list)
          writer.print( g.type ).print( " Rogue" )
          writer.print( type.cpp_name ).print( "_" ).print( g.cpp_name )
          writer.print( " = " ).print_default_value( g.type )
          writer.println( ";" )
        endForEach
      endForEach
      writer.println

      # Trace Prototypes
      forEach (type in type_list)
        if (type.has_object_references and not type.is_reference_array and not type.is_aspect)

          local trace_name = type.cpp_name
          if (type.is_array and type.element_type.is_compound)
            trace_name = Program.validate_cpp_name( type.name )
          endIf

          writer.print(   "void Rogue" ).print( trace_name ).println( "_trace( void* obj );" )
        endIf
      endForEach
      writer.println

      # Trace Functions
      forEach (type in type_list)
        if (type.has_object_references and not type.is_reference_array and not type.is_aspect)

          local trace_name = type.cpp_name
          if (type.is_array and type.element_type.is_compound)
            trace_name = Program.validate_cpp_name( type.name )
          endIf

          writer.print(   "void Rogue" ).print( trace_name ).println( "_trace( void* obj )" )
          writer.println( "{" )
          writer.indent += 2

          if (type.is_compound)
            local uses_link = false
            forEach (p in type.property_list)
              if (p.type.is_reference)
                uses_link = true
                escapeForEach
              endIf
            endForEach
            if (uses_link) writer.println "void* link;"

            print_property_trace_code( type, writer )

          elseIf (type.is_array)
            # We know this is not a reference array and so it must be an array of
            # compounds containing references.
            writer.println @|RogueArray* array = (RogueArray*) obj;
                            |int count;

            writer.print( type.element_type ).println( "* cur;" )

            writer.println @|
                            |if ( !array || array->object_size < 0 ) return;
                            |array->object_size = ~array->object_size;
                            |
                            |count = array->count;

            writer.print( "cur = ((" ).print( type.element_type.cpp_class_name ).println( "*)(array->as_bytes)) - 1;" )

            writer.println( "while (--count >= 0)" )
            writer.println( "{" )
            writer.print(   "  Rogue" ).print( type.element_type.cpp_name ).println( "_trace( ++cur );" )
            writer.println( "}" )

          else
            # Standard object with reference properties
            local uses_link = false
            forEach (p in type.property_list)
              if (p.type.is_reference)
                uses_link = true
                escapeForEach
              endIf
            endForEach

            if (uses_link) writer.println "void* link;"

            writer.println @|if ( !obj || ((RogueObject*)obj)->object_size < 0 ) return;
                            |((RogueObject*)obj)->object_size = ~((RogueObject*)obj)->object_size;
                            |
            print_property_trace_code( type, writer )
          endIf

          writer.indent -= 2
          writer.println( "}" )
          writer.println

        endIf
      endForEach
      writer.println

      # Type name index in literal string table
      writer.println "int Rogue_type_name_index_table[] ="
      writer.println "{"
      writer.indent += 2
      forEach (i of type_list)
        local type = type_list[i]
        if (i > 0)
          writer.print ","
          if (i & 15 == 0) writer.println
        endIf
        writer.print( add_literal_string(type.name) )
      endForEach
      writer.println
      writer.indent -= 2
      writer.println "};"

# Property info table
#{
      writer.println "int Rogue_property_info_table[][] ="
      writer.println "{"
      writer.indent += 2

      forEach (type at i in type_list)
        if (i > 0) println ","
        writer.print( "{" ).print( type.property_list.count )
        forEach (p in type.property_list)
          writer.print ","
          writer.print( add_literal_string(p.name) )
          writer.print ","
          writer.print( p.type.index )
        endForEach
        writer.print( "}" )
      endForEach

      writer.println
      writer.indent -= 2
      writer.println "};"
      }#

      # Init Object Fn Table
      writer.println "RogueInitFn Rogue_init_object_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      local first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "init_object()" )
        if (m and not type.omit_output and m.is_used and m.statements.count > 1)
          writer.print "(RogueInitFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Init Fn Table
      writer.println "RogueInitFn Rogue_init_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "init()" )
        if (m and not type.omit_output and m.is_used and m.statements.count > 1)
          # Note: statement.count > 1 because there's a default return.
          writer.print "(RogueInitFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Cleanup Fn Table
      writer.println "RogueCleanUpFn Rogue_clean_up_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "clean_up()" )
        if (m and not type.omit_output and m.is_used and m.statements.count)
          writer.print "(RogueCleanUpFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # to->String Fn Table
      writer.println "RogueToStringFn Rogue_to_string_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        if (type.is_reference)
          local m = type.find_method( "to_String()" )
          if (m and not type.omit_output and m.is_used and m.statements.count)
            writer.print "(RogueToStringFn) "
            writer.print m.cpp_name
          else
            writer.print 0
          endIf
        else
          writer.print 0
        endIf

      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Trace Fn Table
      writer.println "RogueTraceFn Rogue_trace_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        if (type.has_object_references and not type.is_aspect)
          if (type.is_reference_array)
            writer.print "RogueArray_trace"
          else
            local trace_name = type.cpp_name
            if (type.is_array and type.element_type.is_compound)
              trace_name = Program.validate_cpp_name( type.name )
            endIf

            writer.print(   "Rogue" ).print( trace_name ).print( "_trace" )
          endIf
        elseIf (type.is_class)
          writer.print "RogueObject_trace"
        else
          writer.print "0"
        endIf
      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Trace routine
      writer.println "void Rogue_trace()"
      writer.println "{"
      writer.indent += 2

      writer.println "void* link;"
      writer.println "int i;"
      writer.println
      writer.println "// Trace GLOBAL PROPERTIES"
      forEach (type in type_list)
        if (type.has_global_references)
          forEach (g in type.global_list)
            if (g.type.is_reference or g.type.has_object_references)

              if (g.type.is_reference and not g.type.is_array)
                writer.print( "if ((link=Rogue" ).print( type.cpp_name ).print( "_" ).print( g.cpp_name )
                writer.println( ")) ((RogueObject*)link)->type->trace_fn( link );" )

              else
                local trace_class_name = "Object"
                if (g.type.is_array)
                  if (g.type.element_type.is_compound and g.type.element_type.has_object_references)
                    trace_class_name = Program.validate_cpp_name( g.type.name )
                  else
                    trace_class_name = "Array"
                  endIf

                else
                  trace_class_name = Program.validate_cpp_name(g.type.cpp_name)
                endIf

                writer.print( "if ((link=" )
                if (not g.type.is_reference) writer.print( '&' )
                writer.print( "Rogue" ).print( type.cpp_name ).print( "_" ).print( g.cpp_name )
                writer.print( ")) Rogue" ).print( trace_class_name ).println( "_trace( link );" )

              endIf
            endIf
          endForEach
        endIf

      endForEach

      writer.println

      writer.println @|// Trace Class objects and singletons
                      |for (i=Rogue_type_count; --i>=0; )
                      |{
                      |  RogueType* type = &Rogue_types[i];
                      |  if (type->type_info) RogueTypeInfo_trace( type->type_info );
                      |  if (type->_singleton) type->trace_fn( type->_singleton );
                      |}


      writer.indent -= 2
      writer.println "}"
      writer.println

      #writer.println "*/"

      # dynamic method table
      writer.println( "void* Rogue_dynamic_method_table[] =" )
      writer.println( "{" )
      writer.indent += 2
      local table_index = 0
      forEach (type in type_list)
        if (type.is_used)
          table_index = type.print_dynamic_method_table_entries( table_index, writer )
        endIf
      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Base class info table
      local info = Int32[]
      forEach (type in type_list)
        type.collect_type_info( info )
      endForEach

      writer.print(   "int Rogue_type_info_table[" ).print( info.count ).println( "] =" )
      writer.println "{"
      writer.indent += 2
      writer.println "// allocator_index, dynamic_method_table_index, base_class_count, base_class_index[base_class_count], ..."

      first = true
      local items = 0
      forEach (n in info)
        if (first) first = false
        else       writer.print_literal_character( ',', false )  # fix

        ++items
        if (items == 25) writer.println; items = 0

        writer.print n
      endForEach

      if (items > 0) writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Global property pointers
      writer.println(  "void* Rogue_global_property_pointers[] =" )
      writer.println "{"
      writer.indent += 2

      first = true
      forEach (type in type_list)
        if (type.is_class or type.is_compound)
          forEach (p in type.global_list)
            if (first) first = false
            else       writer.println ","
            if (p.is_native) writer.print "0"
            else             writer.print( "(void*) &Rogue" ).print( p.type_context.cpp_name ).print( "_" )
            writer.print( p.cpp_name )
          endForEach
        endIf
      endForEach

      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Property offsets
      writer.println(  "int Rogue_property_offsets[] =" )
      writer.println "{"
      writer.indent += 2

      first = true
      forEach (type in type_list)
        if (type.is_class or type.is_compound)
          forEach (p in type.property_list)
            if (first) first = false
            else       writer.println ","
            if (p.is_native) writer.print( "0" )
            else writer.print( "(int)(intptr_t)&((" ).print( type.cpp_class_name ).print( "*)0)->" ).print( p.cpp_name )
            #writer.print( "(int)offsetof(" ).print( type.cpp_class_name ).print( "," ).print( p.cpp_name ).print( ")" )
          endForEach
        endIf
      endForEach

      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println


      # Object size table
      writer.print(   "int Rogue_object_size_table[" ).print( type_list.count ).println( "] =" )
      writer.println "{"
      writer.indent += 2

      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        writer.print( "(int) sizeof(" ).print( type.cpp_class_name ).print( ")" )
      endForEach

      if (items > 0) writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Attributes table
      writer.print(   "int Rogue_attributes_table[" ).print( type_list.count ).println( "] =" )
      writer.println "{"
      writer.indent += 2

      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        writer.print( type.attributes.flags )
      endForEach

      if (items > 0) writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Allocators
      writer.print( "int Rogue_allocator_count = " ).print( 1 ).println( ";" )
      writer.print( "RogueAllocator Rogue_allocators[" ).print( 1 ).println( "];" )
      writer.println

      # Types
      writer.print( "int Rogue_type_count = " ).print( type_list.count ).println( ";" )
      writer.print( "RogueType Rogue_types[" ).print( type_list.count ).println( "];" )
      writer.println

      # RogueType_X declarations.
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print( "RogueType* RogueType" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      writer.print( "int Rogue_literal_string_count = " ).print( Program.literal_string_list.count ).println( ";" )
      writer.print( "RogueString* Rogue_literal_strings[" ).print( Program.literal_string_list.count ).println( "];" );
      writer.println

      forEach (type in type_list) type.print_global_method_definitions( writer )
      writer.println

      forEach (type in type_list) type.print_method_definitions( writer )
      writer.println

      # configure() method
      writer.println( "void Rogue_configure( int argc, const char* argv[] )" )
      writer.println( "{" )
      writer.indent += 2

      writer.println @|if (Rogue_configured) return;
                      |Rogue_configured = 1;
                      |
                      |Rogue_argc = argc;
                      |Rogue_argv = argv;
                      |
                      |Rogue_configure_gc();
                      |Rogue_configure_types();
                      |std::set_terminate( Rogue_terminate_handler );
                      |


      # Create types
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print("RogueType").print(type.cpp_name).print(" = &Rogue_types[ ").print(type.index).println(" ];")
          # TODO
        endIf
      endForEach
      writer.println

      forEach (i of Program.literal_string_list)
        writer.print(   "Rogue_literal_strings[" ).print(i)
        writer.print("] = (RogueString*) RogueObject_retain( RogueString_create_from_utf8( ")
        local st = Program.literal_string_list[i]
        local encoded_count = writer.print_literal_string( st )
        writer.print( ", " ).print( st.byte_count )
        writer.println( " ) ); " )
      endForEach
      writer.println

      # End of configure()
      writer.indent -= 2
      writer.println( "}" )
      writer.println

      # launch()
      writer.println( "void Rogue_launch()" )
      writer.println( "{" )
      writer.indent += 2

      # Call all init_class() methods
      forEach (type in type_list)
        if (type.is_used)
          local m = type.find_global_method( "init_class()" )
          if (m and m.type_context is type)
            writer.print( m.cpp_name ).println( "();" )
          endIf
        endIf
      endForEach
      writer.println

      # Copy command line args to System class
      writer.println @|RogueSystem_executable_filepath = RogueString_create_from_utf8(
                      |    Rogue_argc ? Rogue_argv[0] : "Rogue", -1 );
                      |
                      |for (int i=1; i<Rogue_argc; ++i)
                      |{
                      |  RogueString_List__add__String( RogueSystem_command_line_arguments,
                      |      RogueString_create_from_utf8( Rogue_argv[i], -1 ) );
                      |}
      writer.println

      # Instantiate all essential singletons
      writer.println "// Instantiate essential singletons"
      forEach (type in type_list)
        if (not type.omit_output and type.is_singleton and type.is_essential)
          writer.print( "ROGUE_SINGLETON( " ).print( type.cpp_name ).println( " );" )
        endIf
      endForEach
      writer.println


      # Call Global.on_launch()
      writer.println @|RogueGlobal__on_launch( (RogueClassGlobal*) (RogueType_singleton(RogueTypeGlobal)) );
                      |Rogue_collect_garbage();

      writer.indent -= 2
      writer.println( "}" )
      writer.println

      # Rogue_update_tasks() method
      writer.println @|bool Rogue_update_tasks()
                      |{
                      |  // Returns true if any tasks are still active
                      |  try
                      |  {

      local uses_tasks = Program.is_type_used("TaskManager")
      if (uses_tasks)
        writer.println @|    RogueClassTaskManager* task_manager = (RogueClassTaskManager*) ROGUE_SINGLETON(TaskManager);
                        |    bool result = RogueTaskManager__update( task_manager );
                        |    Rogue_collect_garbage();
                        |    return result;
      else
        writer.println @|    Rogue_collect_garbage();
                        |    return false;
      endIf

      writer.println @|  }
                      |  catch (RogueException* err)
                      |  {
                      |    printf( "Uncaught exception\n" );
                      |    RogueException__display( err );
                      |    return false;
                      |  }
                      |}
                      |


      # Optional main()
      if (RogueC.generate_main)
        writer.println
        writer.println( @|int main( int argc, const char* argv[] )
                         |{
                         |  try
                         |  {
                         |    Rogue_configure( argc, argv );
                         |    Rogue_launch();
                         |
                         |    while (Rogue_update_tasks()) {}
                         |
                         |    Rogue_quit();
                         |  }
                         |  catch (RogueException* err)
                         |  {
                         |    printf( "Uncaught exception\n" );
                         |    RogueException__display( err );
                         |  }
                         |
                         |  return 0;
                         |}
        )
      endIf

      forEach (plugin in RogueC.plugins)
        plugin.finish_code_file( writer )
      endForEach

      writer.close

    method print_property_trace_code( type:Type, writer:CPPWriter )
      forEach (p in type.property_list)

        if (p.type.is_reference or p.type.has_object_references)

          if (p.type.is_reference and not p.type.is_array)
            writer.print( "if ((link=((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
            writer.println( ")) ((RogueObject*)link)->type->trace_fn( link );" )

          else
            if (p.type.is_compound)
              writer.print( "Rogue" ).print( p.type.cpp_name ).print( "_trace( &" )
              writer.print( "((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
              writer.println( " );" )

            else
              local trace_class_name = "Object"
              if (p.type.is_array)
                if (p.type.element_type.is_compound and p.type.element_type.has_object_references)
                  trace_class_name = Program.validate_cpp_name( p.type.name )
                else
                  trace_class_name = "Array"
                endIf

              else
                trace_class_name = Program.validate_cpp_name(p.type.cpp_name)
              endIf

              writer.print( "if ((link=" )
              writer.print( "((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
              writer.print( ")) Rogue" ).print( trace_class_name ).println( "_trace( link );" )
            endIf

          endIf
        endIf

      endForEach
endAugment


#------------------------------------------------------------------------------
# CPPWriter
#------------------------------------------------------------------------------
class CPPWriter
  PROPERTIES
    filepath : String
    buffer   = StringBuilder()
    indent   = 0
    needs_indent = true
    line_number = 1

    trace_token : Token

    temp_buffer = StringBuilder()

  METHODS
    method init( filepath )

    method close
      local path = File.path( filepath )
      if (path.count) File.create_folder( path )
      File.save( filepath, buffer->String )

    method print_indent
      if (needs_indent)
        needs_indent = false
        forEach (1..indent) buffer.print(' ')
      endIf

    method print( value:Int64 )->CPPWriter
      print_indent
      buffer.print( value )
      return this

    method print( value:Int32 )->CPPWriter
      print_indent
      buffer.print( value )
      return this

    method print( value:Real64 )->CPPWriter
      print_indent

      buffer.print( value )

      return this

    method print( value:Character )->CPPWriter
      # Do we need to check for newlines here?
      print_indent
      buffer.print( value )
      return this

    method print( value:String )->CPPWriter
      local needs_newline = false
      if (value.contains('\n'))
        forEach (line in LineReader(value))
          if (needs_newline)
            println
          endIf
          print_indent
          buffer.print( line )
          needs_newline = true
        endForEach
      else
        print_indent
        buffer.print( value )
      endIf
      return this

    method print_code( code:String )->CPPWriter
      forEach (line in LineReader(code))
        local original_indent = indent
        if (line.begins_with('#')) indent = 0

        println( line )

        indent = original_indent
      endForEach
      return this

    method println->CPPWriter
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Int64 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Int32 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Real64 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:String )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method print( type:Type )->CPPWriter
      print_type_name( type )
      if (type and type.is_reference) buffer.print("*")
      return this

    method print_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      return print( "(" ).print( to_type ).print( ")" )
      return this

    method print_open_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      print( "(" )
      return print_cast( from_type, to_type )

    method print_close_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      print( ")" )
      return this

    method print_cast( from_type:Type, to_type:Type, cmd:Cmd )->CPPWriter
      if (from_type is to_type)
        cmd.write_cpp( this )
      else
        print( "(" )
        print_cast( from_type, to_type )
        cmd.write_cpp( this )
        print( ")" )
      endIf
      return this

    method print_access_operator( type:Type )->CPPWriter
      if (type.is_reference) return print( "->" )
      else                   return print( "." )

    method print_type_name( type:Type )->CPPWriter
      print_indent
      if (type) buffer.print( type.cpp_class_name )
      else       buffer.print( "void" )
      return this

    method print_type_info( type:Type )->CPPWriter
      print_indent
      buffer.print( "RogueType" ).print( type.cpp_name )
      return this

    method print_default_value( type:Type )->CPPWriter
      if (type.is_compound)
        print( type ).print( "()" )
      else
        buffer.print( "0" )
      endIf
      return this

    method print_hex_pair( value:Int32 )->this
      print "\\x"
      print ((value :>>>: 4).to_digit)
      print ((value & 15).to_digit)
      return this

    method print_literal_character( ch:Character, in_string:Logical )->this
      if (ch >= 32 and ch <= 126)
        which (ch)
          case '"'
            if (in_string) print( "\\\"" )
            else           print( "\"" )
          case '\''
            if (in_string) print( "'" )
            else           print( "\\'" )
          case '\\'
            print( "\\\\" )
          others
            print( ch )
        endWhich
      else
        which (ch)
          case 10
            print "\\n"
          others
            # Must print as separate string to avoid C \x ambiguity.  For instance,
            # "This is \x9CCool" is interpreeted as "This is \x9CC" followed by "ool",
            # so we have to generate "This is ""\x9C""Cool".
            print( "\"\"" )  # end of string so far and beginning of hex escape string
            if (ch <= 0x7F)
              print_hex_pair( ch )
            elseIf (ch <= 0x7FF)
              print_hex_pair(0xC0 | ((ch :>>>: 6) & 0x1F))
              print_hex_pair(0x80 | (ch & 0x3F))
            elseIf (ch <= 0xFFFF)
              print_hex_pair( 0xE0 | ((ch :>>>: 12) & 0xF) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            else
              print_hex_pair( 0xF0 | ((ch :>>>: 18) & 0x7) )
              print_hex_pair( 0x80 | ((ch :>>>: 12) & 0x3F) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            endIf
            print( "\"\"" )  # end of hex escape string and continuation of original string
        endWhich
      endIf

      return this

    method print_literal_string( st:String )->this
      if (st is null)
        print( "0" )
        return this
      endIf

      print( "\"" )
      forEach (ch in st)
        print_literal_character( ch, true )
      endForEach
      print( "\"" )

      return this

    method print_native_code( t:Token, type_context:Type, method_context:Method, locals:Local[], code:String, result_type=null:Type )->this
      # $a is a convenience for $(a) with the latter being more flexible
      #
      # $local_var_name
      # $property_name
      # $this
      # $($TypeSpecializer)
      # $retain
      # $release
      forEach (line in LineReader(code))
        local original_indent = indent
        if (line.begins_with('#')) indent = 0

        # Replace $this and other local names ($x, $count, etc) with native
        # variable reads.
        local marker = line.locate( '$' )
        while (marker)
          local name : String

          local i1 = marker.value
          if (i1 > 0) print line.leftmost( i1 )
          local i2 = i1+1
          if (i2 < line.count and line[i2] == '(')
            # We have $(name) or $(name.x)
            ++i2
            while (i2 < line.count and line[i2] != ')') ++i2
            name = line.from( i1+2, i2-1 )
            line = line.from( i2+1 )
          else
            # Just $name
            while (i2 < line.count and line[i2].is_identifier) ++i2
            name = line.from( i1+1, i2-1 )
            line = line.from( i2 )
          endIf

          print_native_marker( t, type_context, method_context, locals, name )

          marker = line.locate( '$' )
        endWhile

        if (line.count)
          if (result_type) print   line
          else             println line
        endIf

        indent = original_indent
      endForEach
      return this

    method print_native_marker( t:Token, type_context:Type, method_context:Method, locals:Local[], name:String )->this
      # name:$(this.type) -> name:this, operation:type
      local operation = name.after_first( '.' )
      name = name.before_first( '.' )

      which (name)
        case "$"
          print "$"

        case "this"
          print_native_code_marker_value( t, name, operation, "THIS", type_context )

        others
          if (name.begins_with('$'))
            # Probably a specializer name like $DataType
            if (type_context.specializers)
              forEach (specializer in type_context.specializers)
                if (specializer.name == name)
                  which (operation)
                    case ""
                      local type = Parser(specializer.tokens).parse_type.organize
                      print( type )
                      return this
                  endWhich
                endIf
              endForEach
            endIf
            if (method_context.source_template)
              forEach (specializer at i in method_context.source_template.type_parameters)
                if (specializer.name == name)
                  which (operation)
                    case ""
                      local type = Parser(t,method_context.name,method_context.name.from_first("<<"))...
                        .parse_specialization_type(i).organize
                      print( type )
                      return this
                  endWhich
                endIf
              endForEach
            endIf
            throw t.error( "Unrecognized native code insertion marker: $$.$" ('$',name,operation) )
          endIf

          if (method_context and locals)
            forEach (v in locals step -1)
              if (v.name == name)
                print_native_code_marker_value( t, name, operation, v.cpp_name, v.type )
                escapeWhich
              endIf
            endForEach
          endIf

          local p = type_context.property_lookup[ name ]
          if (p)
            if (type_context.is_reference)
              print_native_code_marker_value( t, name, operation, "THIS->" + p.cpp_name, p.type )
            else
              print_native_code_marker_value( t, name, operation, "THIS." + p.cpp_name, p.type )
            endIf
            escapeWhich
          endIf

          print( "$" ).print( name )
      endWhich
      return this

    method print_native_code_marker_value( t:Token, name:String, operation:String, default:String, type:Type )
      which (operation)
        case "release"
          if (type and type.is_reference)
            print( '(' ).print_cast( Program.type_Object, type ).print( "RogueObject_release(" )
            print_cast( type, Program.type_Object ).print( default ).print( "))" )
          else
            print( default )
          endIf
        case "retain"
          if (type and type.is_reference)
            print( '(' ).print_cast( Program.type_Object, type ).print( "RogueObject_retain(" )
            print_cast( type, Program.type_Object ).print( default ).print( "))" )
          else
            print( default )
          endIf
        case "type"
          print( type )
        case ""
          print( default )
        others
          throw t.error( "Unrecognized native code insertion marker: $$.$" ('$',name,operation) )
      endWhich

  method print_arg ( arg:Cmd, param_type=null:Type, cast_to=null:Type )
    # Prints an argument to a call
    #
    # Note that the argument here may not be an argument as far as *Rogue*
    # is concerned, but it's an argument as far as C++ is concerned (e.g.,
    # it may be the "this" pointer).
    # If param_type is given and is an aspect, we do an aspect-wrap.
    # If cast_to is given, we'll insert a cast to this type.

    local close_paren = 0

    # We want to increase the reference count of arguments we're passing,
    # which happens by wrapping them in ROGUE_ARG.  If this argument is
    # guaranteed to have a lifetime at least as long as the call we're
    # making, we can skip this.
    if (arg instanceOf CmdReadLocal)
      noAction # Current frame won't die before call
    elseIf (arg instanceOf CmdReadSingleton)
      noAction # Singletons live forever
    elseIf (arg instanceOf CmdLiteral)
      noAction # Literals live forever
    else
      # Can't be sure.  Increase the ref count.
      print( "ROGUE_ARG(" )
      ++ close_paren
    endIf

    if (param_type and param_type.is_aspect)
      print( "(" ).print_cast(arg.type, param_type).print("(")
      close_paren += 2
    endIf

    if (cast_to)
      print_cast( arg.type, cast_to, arg )
    elseIf (arg.type is not param_type)
      print_cast( arg.type, param_type, arg )
    else
      arg.write_cpp( this )
    endIf

    while (close_paren)
      -- close_paren
      print( ")" )
    endWhile

  method mark_statement_start( statement_filepath:String, start_line:Int32, end_line:Int32 )
    #@trace "STATEMENT ", this.filepath, this.line_number, statement_filepath, start_line, end_line

  method mark_statement_end
    noAction

  method mark_method_start( t:Type, m:Method )
    if (m.omit_output) return
    #@trace "METHOD ", this.filepath, this.line_number, t.name, m.name

  method mark_method_end
    noAction

  method mark_routine_start ( m:Method )
    if (m.omit_output) return
    #@trace "ROUTINE ", this.filepath, this.line_number, m.name

  method mark_routine_end
    noAction

  method update_trace_info( t:Token )
    if (trace_token and t and t.filepath)
      if (t.filepath is not trace_token.filepath)
        if (RogueC.debug_mode)
          print( ";__trace.filename = \"" ).print( t.filename ).println( "\";" )
          print( ";__trace.line = " ).print( t.line ).println( ";" )
        endIf
      elseIf (t.line != trace_token.line)
        if (RogueC.debug_mode) print( ";__trace.line = " ).print( t.line ).println( ";" )
      endIf
    endIf
    trace_token = t
endClass


#------------------------------------------------------------------------------
# RogueC
#------------------------------------------------------------------------------
augment RogueC
  METHODS
    method launch
      <<collect_supported_targets>>
      supported_targets.add( "C++" )

    method write_output
      <<target_specific_code>>
      if (compile_targets["C++"]) write_cpp; return

    method write_cpp
      if (output_filepath is null)
        output_filepath = File.filename(first_filepath)
        if (output_filepath.to_lowercase.ends_with(".rogue")) output_filepath = output_filepath.leftmost(-6)
      else
        if (File.is_folder(output_filepath))
          output_filepath += "/"
          local filename = File.filename( first_filepath )
          if (filename.to_lowercase.ends_with(".rogue")) output_filepath += filename.leftmost(-6)
          else                                           output_filepath += "RogueProgram"

        elseIf (output_filepath.to_lowercase.ends_with(".cpp"))
          output_filepath = output_filepath.leftmost(-4)
        endIf
      endIf

      Program.write_cpp( output_filepath )
      RogueC.on_compile_finished

      if (compile_output)
        local exe = output_filepath
        if (exe.contains('/'))
          exe = File.path(exe) + "/" + File.filename(exe).to_lowercase
        else
          exe = exe.to_lowercase
        endIf
        local cmd = "clang++ -Wall -std=c++11 -fno-strict-aliasing $.cpp -o $" (output_filepath,exe)
        if (execute_args) cmd += " && ./$ $" (exe,execute_args)
        println cmd
        println
        if (System.run(cmd)) System.exit( 1 )
      endIf

endAugment


#------------------------------------------------------------------------------
# Type
#------------------------------------------------------------------------------
augment Type
  PROPERTIES
    cpp_name       : String
    cpp_class_name : String
    cpp_type_name  : String

  METHODS
    method assign_cpp_name
      if (cpp_name) return
      cpp_name = Program.validate_cpp_name( name )

      if (is_array or this is Program.type_NativeArray)
        cpp_class_name = "RogueArray"
        cpp_name = "Array"

      elseIf (this.is_primitive or this.simplify_name)
        cpp_class_name = "Rogue" + cpp_name

      elseIf (is_list)
        cpp_class_name = "Rogue" + cpp_name

      elseIf (is_optional)
        cpp_name = Program.validate_cpp_name( "Optional" + element_type.cpp_name )
        cpp_class_name = "Rogue" + cpp_name

      else
        cpp_class_name = "RogueClass" + cpp_name
      endIf

      cpp_type_name = "RogueType" + cpp_name

      forEach (s in global_list)
        s.cpp_name = Program.validate_cpp_name( s.name )
      endForEach

      forEach (p in property_list)
        if (p.is_native) p.cpp_name = p.name
        else             p.cpp_name = Program.validate_cpp_name( p.name )
      endForEach

    method print_data_definition( writer:CPPWriter )
      if (omit_output or is_primitive) return

      writer.print( "struct " ).print( cpp_class_name )
      local is_error = false
      if (is_reference)
        if (instance_of(Program.type_Exception))
          is_error = true
          writer.print( " : " ).print_type_name( base_class )
        else
          writer.print( " : RogueObject" )
        endIf
      endIf
      writer.println.println( "{" )
      writer.indent += 2

      # Properties
      if (not is_aspect)
        writer.println "// PROPERTIES"
        forEach (p in property_list)
          if (not is_error or p.type_context is this)
            if (is_compound and p.type.is_reference)
              writer.print( "ROGUE_DEF_COMPOUND_REF_PROP(")
              writer.print( p.type ).print(",").print( p.cpp_name )
              writer.print( ");")
            elseIf (p.is_native)
              writer.print_native_code( p.t, this, null, null, p.name )
            else
              writer.print( p.type ).print(" ").print( p.cpp_name ).println(";")
            endIf
          endIf
        endForEach
        writer.println
      endIf

      if (is_compound)
        if (property_list.count)
          # Default Constructor
          writer.print( this ).print( "() { memset( this, 0, sizeof(" ).print( this ).println( ") ); }" )
          writer.println

          if (is_optional)
            # Value Constructor, exists->true
            writer.print( this ).print( "( " ).print( property_list.first.type )
            writer.println( " value, bool exists=true ) : value(value), exists(exists) {}" )
          else
            # Standard Constructor
            local native_property_count = 0
            contingent
              forEach (p in property_list)
                if (p.is_native) ++native_property_count
              endForEach
              necessary (native_property_count == 0)

            satisfied
              # No native properties - use property initializer syntax
              writer.print( this ).print( "( " )
              local first = true
              forEach (p in property_list)
                if (first) first = false
                else       writer.print( ", " )
                writer.print( p.type ).print(" ").print( p.cpp_name )
              endForEach
              writer.print( " ) : " )
              first = true
              forEach (p in property_list)
                if (first) first = false
                else       writer.print( ", " )
                writer.print( p.cpp_name ).print("(").print( p.cpp_name ).print(")")
              endForEach
              writer.println( " {}" )
              writer.println

            unsatisfied
              # Native properties - start with a memset and then assign non-native properties individually.
              # If there are no non-native properties then just skip this entirely.
              if (native_property_count != property_list.count)
                writer.print( this ).print( "( " )
                local first = true
                forEach (p in property_list)
                  if (not p.is_native)
                    if (first) first = false
                    else       writer.print( ", " )
                    writer.print( p.type ).print(" ").print( p.cpp_name )
                  endIf
                endForEach
                writer.println( " )" )
                writer.println( "{" )
                writer.indent += 2

                writer.print( "memset( this, 0, sizeof(" ).print( this ).println( ") );" )

                forEach (p in property_list)
                  if (not p.is_native)
                    writer.print( "this->" ).print( p.cpp_name ).print(" = ").print( p.cpp_name ).println(";")
                  endIf
                endForEach

                writer.indent -= 2
                writer.println( "}" )
                writer.println
              endIf
            endContingent
          endIf
        endIf

        if (not is_aspect)
          # Default operator== and operator!=
          writer.print( "bool operator==( const ").print_type_name( this ).println( " &other ) const" )
          writer.println( "{" )
          writer.indent += 2
          if (is_optional)
            writer.println @|if (exists)
                            |{
                            |  if (other.exists) return value == other.value;
                            |  else              return false;
                            |}
                            |else
                            |{
                            |  if (other.exists) return false;
                            |  else              return true;
                            |}
          else
            writer.print( "return (0 == memcmp(this,&other,sizeof(" ).print( this ).println( ")));" )
          endIf
          writer.indent -= 2
          writer.println( "}" )
          writer.println

          writer.print( "bool operator!=( const ").print_type_name( this ).println( " &other ) const" )
          writer.println @|{
                          |  return !(*this == other);
                          |}
                          |

        endIf

      endIf

      writer.indent -= 2
      writer.println( "};" )

    method print_global_method_prototypes( writer:CPPWriter )
      forEach (m in global_method_list)
        if (m.type_context is this) m.print_prototype( writer )
      endForEach

    method print_global_method_definitions( writer:CPPWriter )
      forEach (m in global_method_list)
        if (m.type_context is this)
          writer.mark_routine_start( m )
          m.print_definition( writer )
          writer.mark_routine_end
        endIf
      endForEach

    method print_method_prototypes( writer:CPPWriter )
      forEach (m in method_list)
        if (m.type_context is this) m.print_prototype( writer )
      endForEach

    method determine_cpp_method_typedefs( list:String[], lookup:Table<<String,Method>> )
      local buffer = StringBuilder()
      forEach (m in method_list)
        if (not m.is_macro and m.is_dynamic and m.is_used)
          buffer.clear
          if (m.return_type)
            buffer.print( m.return_type.cpp_class_name )
            if (m.return_type.is_reference) buffer.print('*')
          else
            buffer.print( "void" )
          endIf
          buffer.print( "(*)(" )
          buffer.print( m.type_context.cpp_class_name ).print("*")
          forEach (i of m.parameters)
            buffer.print(',')
            local param_type = m.parameters[i].type
            buffer.print( param_type.cpp_class_name )
            if (param_type.is_reference) buffer.print('*')
          endForEach
          buffer.print( ")" )
          local sig = buffer->String
          local mapping = lookup[sig]
          if (mapping)
            m.cpp_typedef = mapping.cpp_typedef
            if (not mapping.called_dynamically and m.called_dynamically)
              #list[ list.locate(mapping)! ] = m
              lookup[ sig ] = m
            endIf
          else
            m.cpp_typedef = "ROGUEM" + list.count
            lookup[sig] = m
            list.add( sig )
          endIf
        endIf
      endForEach

    method print_dynamic_method_table_entries( at_index:Int32, writer:CPPWriter )->Int32
      if (not is_reference) return at_index

      dynamic_method_table_index = at_index

      local i2 = method_list.count - 1
      while (i2 > 0)
        local m = method_list[ i2 ]
        if (not m.is_macro and m.is_dynamic and m.is_used) escapeWhile
        --i2
      endWhile

      local print_type_name = true
      forEach (i in 0..i2)
        local m = method_list[i]
        if (not m.is_macro)
          if (m.is_dynamic and m.is_used and not m.is_abstract)
            # Note: can't cast multiple overloaded fns directly to void*, must go through fn pointer type first
            writer.print( "(void*) (" ).print( m.cpp_typedef ).print(") ").print( m.cpp_name ).print( "," )
          else
            writer.print( "0," ) #.print( " // " ).print(m.type_context.name).print(".").print( m.signature )
          endIf
          if (print_type_name) print_type_name = false; writer.print( " // " ).print( name )
          writer.println
          ++at_index
        endIf
      endForEach

      return at_index

    method print_method_definitions( writer:CPPWriter )
      forEach (m in method_list)
        if (m.type_context is this)
          writer.mark_method_start(this, m)
          m.print_definition( writer )
          writer.mark_method_end
        endIf
      endForEach

    method print_type_configuration( writer:CPPWriter )
      if (omit_output) return
      writer.print( "  type_" ).print( cpp_name ).print( " = Rogue_types[" ).print( index )
      writer.print( "].init( " ).print( index ).print( ", \"" ).print( cpp_class_name ).print( "\", sizeof(Class" )
      writer.print( cpp_class_name ).println( ") );" )

endAugment


#------------------------------------------------------------------------------
# Method
#------------------------------------------------------------------------------
augment Method
  PROPERTIES
    cpp_name     : String
    cpp_typedef  : String

  METHODS
    method cloned->Method
      <<initialize_result>>
      result.cpp_name = cpp_name
      result.cpp_typedef = cpp_typedef

    method assign_cpp_name
      if (cpp_name) return
      local buffer = StringBuilder()
      buffer.print( type_context.name ).print( "__" )
      buffer.print( name )
      if (parameters.count)
        buffer.print "_"
        forEach (param in parameters)
          buffer.print "_"
          buffer.print( param.type.cpp_name )
        endForEach
      endIf
      cpp_name = "Rogue" + Program.validate_cpp_name( buffer->String )

    method incorporate( into_type:Type )->Method
      <<initialize_m>>
      m.cpp_name = null

    method print_prototype( writer:CPPWriter )
      if (omit_output) return
      print_signature( writer )
      writer.println( ";" )

    method print_signature( writer:CPPWriter )
      writer.print( return_type ).print(" ").print( cpp_name )
      writer.print( "(" )
      local first = true
      if (not is_global)
        first = false
        writer.print( " " )
        if (type_context.is_aspect)
          writer.print( Program.type_Object )
        else
          writer.print( type_context )
        endIf
        writer.print( " THIS" )
      endIf
      if (parameters.count)
        forEach (param in parameters)
          if (first) writer.print( " " ); first = false
          else       writer.print( ", " )
          if (param.parameter_needs_gc)
            writer.print( param.type ).print( " " ).print( param.parameter_cpp_name )
          else
            writer.print( param.type ).print( " " ).print( param.cpp_name )
          endIf
        endForEach
      endIf
      if (not first) writer.print( " " )
      writer.print( ")" )

    method print_definition( writer:CPPWriter )
      if (omit_output) return

      print_signature( writer )
      writer.println
      writer.println "{"
      writer.indent += 2
      forEach (param in parameters)
        if (param.parameter_needs_gc)
          writer.print("ROGUE_DEF_LOCAL_REF(").print(param.type).print(",").print(param.cpp_name).print(",").print(param.parameter_cpp_name).println(");")
        endIf
      endForEach
      if (type_context.is_aspect and not is_global)
        writer.println( "switch (THIS->type->index)" );
        writer.println "{"
        writer.indent += 2
        if (incorporating_classes)
          forEach (ic in incorporating_classes)
            if (ic.is_used)
              local m = ic.find_method(signature)
              if (m.is_used)
                writer.print("case ").print(ic.index).println(":")
                if (return_type)
                  writer.print( "  return " )
                  if (return_type is not m.return_type)
                    # Manual widening cast
                    writer.print( "(" ).print( return_type ).print( ")" )
                  endIf
                else
                  writer.print( "  " )
                endIf
                writer.print( m.cpp_name ).print( "( (" ).print( m.type_context ).print( ")THIS" )
                forEach (param in parameters)
                  writer.print( ", " ).print( param.cpp_name )
                endForEach
                writer.println( " );" )
              endIf
            endIf
          endForEach
        endIf
        if (return_type)
          writer.println( "default:" )
          writer.print( "  return " ).print_default_value( return_type ).println( ";" )
        endIf
        writer.indent -= 2
        writer.println "}"
      else
        if (RogueC.debug_mode)
          writer.trace_token = t
          writer.print( ''RogueDebugTrace __trace( "'' )
          writer.print( type_context.name ).print( "." ).print( signature ).print( ''", "'' )
          writer.print( t.filename ).print( ''", '' ).print( t.line )
          writer.println( '' );'' )
        endIf
        statements.write_cpp( writer )
      endIf

      writer.indent -= 2
      writer.println "}"
      writer.println

endAugment

#------------------------------------------------------------------------------
# Property
#------------------------------------------------------------------------------
augment Property
  PROPERTIES
    cpp_name      : String

  METHODS
    method cloned->Property
      <<init_result>>
      result.cpp_name = cpp_name
endAugment

#------------------------------------------------------------------------------
# Local
#------------------------------------------------------------------------------
augment Local
  PROPERTIES
    _cpp_name           : String
    _parameter_cpp_name : String

  METHODS
    method cloned( clone_args=null:CloneArgs )->Local
      <<init_result>>
      result._cpp_name = _cpp_name
      result._parameter_cpp_name = _parameter_cpp_name

    method cpp_name->String
      if (not _cpp_name) _cpp_name = Program.validate_cpp_name( name + "_" + index );
      return _cpp_name

    method parameter_cpp_name->String
      if (not _parameter_cpp_name) _parameter_cpp_name = Program.create_unique_id
      return _parameter_cpp_name

    method parameter_needs_gc->Logical
      #NOTE: We could always return false here if not in auto GC mode.  This
      #      might be slightly more efficient (especially if there was no C++
      #      optimization), but would mean that you couldn't switch GC mode
      #      by just tweaking defines in the output .h file.
      return is_modified and type.is_reference
endAugment

#------------------------------------------------------------------------------
# Cmd
#------------------------------------------------------------------------------
augment Cmd
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      throw t.error( "[INTERNAL] $::write_cpp() is not defined." (type_name) )
endAugment

augment CmdStatementList
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical, &skip_trace_update )
      if (count?) writer.mark_statement_start(this[0].t.filepath, this[0].t.line, this[count-1].t.line)
      forEach (statement in this)
        if (not skip_trace_update and statement.generates_output) writer.update_trace_info( statement.t )
        statement.write_cpp( writer, true )
        if (statement.requires_semicolon) writer.println ";"
      endForEach
      if (count?) writer.mark_statement_end
endAugment

augment CmdArgs
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      throw this[0].t.error( "[INTERNAL] $::write_cpp() is not defined." (type_name) )
endAugment

augment CmdLocalDeclaration
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (local_info.type.is_reference)
        if (skip_initialization)
          writer.print("ROGUE_DEF_LOCAL_REF_NULL(").print(local_info.type).print(",").print(local_info.cpp_name).print(")")
        elseIf
          writer.print("ROGUE_DEF_LOCAL_REF(").print(local_info.type).print(",").print(local_info.cpp_name).print(",")
          if (local_info.initial_value)
            writer.print( "(" ).print_cast( local_info.initial_value.type, local_info.type )
            local_info.initial_value.write_cpp( writer )
            writer.print( ")" )
          else
            writer.print_default_value( local_info.type )
          endIf
          writer.print(")")
        endIf
      else
        writer.print( local_info.type ).print(" ").print( local_info.cpp_name )
        if (not skip_initialization)
          writer.print(" = ")
          if (local_info.initial_value)
            writer.print( "(" ).print_cast( local_info.initial_value.type, local_info.type )
            local_info.initial_value.write_cpp( writer )
            writer.print( ")" )
          else
            writer.print_default_value( local_info.type )
          endIf
        endIf
      endIf
endAugment


augment CmdReturn
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value)
        writer.print( "return (" ).print( value.type ).print( ")(" )
        value.write_cpp( writer )
        writer.print( ")" )
      else
        writer.print "return"
      endIf
endAugment


augment CmdBlock
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )
      if (escape_label) writer.print( escape_label ).println( ":;" )
endAugment


augment CmdIf
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if (" )
      if (condition instanceOf CmdLiteralLogical and not (condition as CmdLiteralLogical).value)
        # Surround with extra parens to prevent dead code warning
        writer.print( "(" )
        condition.write_cpp( writer )
        writer.print( ")" )
      else
        condition.write_cpp( writer )
      endIf
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      if (else_statements)
        if (else_statements.count == 1 and else_statements.first instanceOf CmdIf)
          # Write the else/if in the "else if" style.
          writer.print( "else " )
          else_statements.write_cpp( writer, &skip_trace_update )
        else
          # General 'else' block.
          writer.println( "else" )
          writer.println( "{" )
          writer.indent += 2
          else_statements.write_cpp( writer )
          writer.indent -= 2
          writer.println( "}" )
        endIf
      endIf

      if (escape_label) writer.print( escape_label ).println( ":;" )

endAugment


augment CmdSwitch
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "switch (" )
      expression.write_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2

      forEach (c in cases)
        forEach (condition in c.conditions)
          writer.print( "case " )
          condition.write_cpp( writer )
          writer.println( ":" )
        endForEach
        writer.println "{"
        writer.indent += 2
        c.statements.write_cpp( writer )
        writer.println "break;"
        writer.indent -= 2
        writer.println "}"
      endForEach

      if (case_others)
        writer.println "default:"
        writer.println "{"
        writer.indent += 2
        case_others.statements.write_cpp( writer )
        writer.indent -= 2
        writer.println "}"
      endIf

      writer.indent -= 2
      writer.println( "}" )
endAugment


augment CmdContingent
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "{" ); writer.indent += 2
      writer.println( "{" ); writer.indent += 2

      writer.println( "{" ); writer.indent += 2
      statements.write_cpp( writer )
      writer.println( "}" ); writer.indent -= 2

      # 'satisfied_returns' and 'body_returns' are pretty kludgy ways to get rid of
      # some C++ warnings for now... need to replace with a more robust control path
      # tracing system at some point.

      if (satisfied_label)   writer.print( satisfied_label ).println( ":;" )
      if (satisfied_statements)
        writer.println( "{" ); writer.indent += 2
        satisfied_statements.write_cpp( writer )
        local satisfied_returns = (satisfied_statements.count and satisfied_statements.last instanceOf CmdReturn)
        writer.println( "}" ); writer.indent -= 2
        if (not satisfied_returns)
          escape_label_used = true
          writer.print( "goto " ).print( escape_label ).println( ";" )
        endIf
      else
        local body_returns = (statements.count and statements.last instanceOf CmdReturn)
        if (not body_returns)
          escape_label_used = true
          writer.print( "goto " ).print( escape_label ).println( ";" )
        endIf
      endIf

      writer.indent -= 2
      writer.println( "}" )

      if (unsatisfied_label)      writer.print( unsatisfied_label ).println( ":;" )
      if (unsatisfied_statements)
        writer.println( "{" ); writer.indent += 2
        unsatisfied_statements.write_cpp( writer )
        writer.println( "}" ); writer.indent -= 2
      endIf

      writer.indent -= 2
      writer.println( "}" )

      if (escape_label_used) writer.print( escape_label ).println( ":;" )
endAugment


augment CmdGenericLoop
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (control_statements)
        writer.println( "{" )
        writer.indent += 2

        if (control_statements)
          forEach (statement in control_statements)
            statement.write_cpp( writer )
            writer.println( ";" )
          endForEach
        endIf

      endIf

      if (upkeep or not condition)
        writer.print( "for (;" )
        if (condition) condition.write_cpp( writer )
        writer.print( ";" )
        local first = true
        if (upkeep)
          forEach (statement in upkeep)
            if (first) first = false
            else       writer.print( "," )
            statement.write_cpp( writer )
          endForEach
        endIf
        writer.println( ")" )
      else
        writer.print( "while (" )
        condition.write_cpp( writer )
        writer.println( ")" )
      endIf
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      if (control_statements)
        writer.indent -= 2
        writer.println( "}" )
      endIf

      if (escape_label)
        writer.print( escape_label ).println( ":;" )
      endIf

endAugment


augment CmdTry
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println "ROGUE_TRY"
      #writer.println "try"
      writer.println "{"
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println "}"
      forEach (c in catches)
        c.write_cpp( writer )
      endForEach

      writer.println( "ROGUE_END_TRY" )

      if (escape_label)
        writer.print( escape_label ).println( ":;" )
      endIf
endAugment

augment CmdCatch
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      #writer.print( "catch ( " ).print( error_var.type ).print( " " ).print( error_var.cpp_name ).println( " )" )
      if (error_var)
        writer.print( "ROGUE_CATCH( " ).print( error_var.type.cpp_class_name ).print( "," ).print( error_var.cpp_name ).println( " )" )
      else
        writer.print( "ROGUE_CATCH_NO_VAR(" ).print( error_type.cpp_class_name ).println( ")" )
      endIf
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )
endAugment

augment CmdThrow
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "ROGUE_THROW(" ).print( expression.type.cpp_class_name ).print( "," )
      expression.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdEscape
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "goto " + target_cmd.escape_label

endAugment


augment CmdNextIteration
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "continue"

endAugment


augment CmdNecessary
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if ( !(" )
      condition.write_cpp( writer )
      writer.print( ") ) goto " ).print( target_cmd.unsatisfied_label )
endAugment


augment CmdSufficient
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if (" )
      condition.write_cpp( writer )
      writer.print( ") goto " ).print( target_cmd.satisfied_label )
endAugment

augment CmdLiteralNull
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "NULL" )
endAugment

augment CmdLiteralReal64
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value == value)
        if (value - value == 0)
          writer.print( value )
        else
          if (value > 0) writer.print( "(1.0/0.0)" )   #  infinity
          else           writer.print( "(-1.0/0.0)" )  # -infinity
        endIf
      else
        writer.print( "(0.0/0.0)" )  # NaN
      endIf
endAugment


augment CmdLiteralInt64
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( value ).print( "LL" )
endAugment

augment CmdLiteralInt32
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( value )
endAugment


augment CmdLiteralCharacter
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "(RogueCharacter)" )
      if (value >= 32 and value <= 126)
        which (value)
          case 10:   writer.print( "'\\n'" )
          case '\\': writer.print( "'\\\\'" )
          case '\'': writer.print( "'\\''" )
          others
            writer.print( "'" )
            writer.print_literal_character( value, false )
            writer.print( "'" )
        endWhich
      else
        writer.print( value->Int32 )
      endIf
endAugment


augment CmdLiteralLogical
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value) writer.print "true"
      else       writer.print "false"
endAugment


augment CmdLiteralString
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value)
        writer.print( "Rogue_literal_strings[" ).print( index ).print( "]" )
      else
        writer.print( "0" );
      endIf
endAugment

augment CmdAccess
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
println StackTrace()
      throw t.error( "[INTERNAL] $::write_cpp() is not defined (access name $)." (type_name,name) )
endAugment

augment CmdCreateObject
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print( "ROGUE_CREATE_REF(" ).print(of_type).print(",")

      #writer.print("RogueType_create_object(RogueType").print(type.cpp_name).print(",0)")
      writer.print("ROGUE_CREATE_OBJECT(").print(type.cpp_name).print(")")

      if (not is_statement) writer.print( ")" )
endAugment


augment CmdCreateCompound
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( of_type ).print( "(" )
      if (args.count)
        writer.print( " " )
        local first = true
        forEach (arg in args)
          if (first) first = false
          else       writer.print( ", " )
          arg.write_cpp( writer )
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )
endAugment


augment CmdAssign
  METHODS
endAugment

augment CmdThisContext
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "THIS"
endAugment

augment CmdReadSingleton
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not of_type.is_singleton)
        throw t.error( "$ is not a singleton." (of_type.name) )
      endIf
      writer.print( "((" ).print( of_type.cpp_class_name )
      if (of_type.is_reference) writer.print( "*" )
      writer.print( ")ROGUE_SINGLETON(" ).print( of_type.cpp_name ).print( "))" )
endAugment

augment CmdWriteSingleton
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not of_type.is_singleton)
        throw t.error( "$ is not a singleton." (of_type.name) )
      endIf
      writer.print( "RogueType" ).print( of_type.cpp_name ).print( "->_singleton = " )
      if (new_value.type is not of_type) writer.print_cast( new_value.type, of_type )
      new_value.write_cpp( writer )
      writer.println( ";" )
endAugment

augment CmdReadLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name )

endAugment

augment CmdWriteLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name ).print(" = ")
      writer.print( "((" ).print( local_info.type ).print( ")" )
      new_value.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdReadGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print_open_cast( global_info.type, global_info.type )

      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name )
      if (not is_statement) writer.print_close_cast( global_info.type, global_info.type )
endAugment


augment CmdWriteGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name ).print(" = ")

      if (global_info.type is new_value.type)
        new_value.write_cpp( writer )
      else
        writer.print( "((" ).print( global_info.type ).print( ")" )
        new_value.write_cpp( writer )
        writer.print( ")" )
      endIf
endAugment

augment CmdReadProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print_open_cast( property_info.type, property_info.type )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name )
      if (not is_statement) writer.print_close_cast( property_info.type, property_info.type )
endAugment

augment CmdWriteProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" = ")

      if (property_info.type is new_value.type)
        new_value.write_cpp( writer )
      else
        writer.print( "((" ).print( property_info.type ).print( ")" )
        new_value.write_cpp( writer )
        writer.print( ")" )
      endIf
endAugment

augment CmdCallRoutine
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )

      writer.print( method_info.cpp_name )
      writer.print( "(" )
      if (args.count)
        writer.print( " " )
        local i = 0
        forEach (arg in args)
          if (i > 0) writer.print( ", " )
          writer.print_arg( arg, method_info.parameters[i].type )
          ++i
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallAspectMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context, &cast_to=Program.type_Object )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i].type )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallDynamicMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      if (method_info.is_overridden)
        writer.print( "Rogue_call_" ).print( method_info.cpp_typedef )
        writer.print( "( " )
        writer.print( method_info.index ).print( ", " )
        writer.print_arg( context, &cast_to = method_info.type_context )
        local i = 0
        forEach (arg in args)
          writer.print( ", " )
          writer.print_arg( arg, method_info.parameters[i].type )
          ++i
        endForEach
        writer.print( " )" )

      else
        CmdCallStaticMethod( t, context, method_info, args ).write_cpp( writer, is_statement )
      endIf
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallStaticMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context, &cast_to = method_info.type_context )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i].type )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallNativeRoutine
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      local i = 0
      forEach (arg in args)
        if (i > 0) writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i].type )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallNativeMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i].type )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallInlineNative
  METHODS
    method print_this( writer:CPPWriter )
      throw t.error( "Illegal use of '$this' in global method." )

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      which (adjust_delta)
        case -1: writer.print( "--" )
        case  1: writer.print( "++" )
      endWhich

      local st = method_info.native_code

      local dollar = st.locate('$')
      while (dollar)
        writer.print( st.from(0,dollar.value-1) )
        st = st.from( dollar.value+1 )

        local name  : String
        local param : Local
        if (st.begins_with('('))
          # $(name)
          name = st.before_first(')').from(1)
          st = st.after_first( ')' )

          forEach (p in method_info.parameters)
            if (p.name == name)
              param = p
              escapeForEach
            endIf
          endForEach

        else
          # $name
          local best_match : Local
          forEach (p in method_info.parameters)
            if (st.begins_with(p.name))
              if (best_match is null or p.name.count > best_match.name.count) best_match = p
            endIf
          endForEach

          if (best_match)
            param = best_match
            name = param.name
            st = st.from( best_match.name.count )
          elseIf (st.begins_with("this"))
            print_this( writer )
            st = st.from( 4 )
          endIf
        endIf

        if (param)
          args[ param.index ].write_cpp( writer )
        elseIf (name)
          writer.print_native_marker( t, method_info.type_context, method_info, null, name )
        endIf

        dollar = st.locate('$')
      endWhile

      writer.print( st )
endAugment


augment CmdCallInlineNativeMethod
  METHODS
    method print_this( writer:CPPWriter )
      context.write_cpp( writer )
endAugment


augment CmdUnary
  METHODS
    method cpp_prefix_symbol->String
      return prefix_symbol

    method cpp_suffix_symbol->String
      return suffix_symbol

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( cpp_prefix_symbol ).print( "(" )
      operand.write_cpp( writer )
      writer.print( ")" ).print( cpp_suffix_symbol )
endAugment

augment CmdLogicalize
  METHODS
    method cpp_prefix_symbol->String
      return "!!"

    method cpp_suffix_symbol->String
      return ""
endAugment

augment CmdLogicalNot
  METHODS
    method cpp_prefix_symbol->String
      return "!"
endAugment


augment CmdBinary
  METHODS
    method cpp_symbol->String
      return symbol

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (requires_parens) writer.print( "(" )
      left.write_cpp( writer )
      writer.print( " " ).print( cpp_symbol ).print( " " )
      right.write_cpp( writer )
      if (requires_parens) writer.print( ")" )
endAugment

#{
augment CmdMod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local cast = "(RogueInt32)"
      if (this_type is Program.type_Real64)     cast = "(RogueReal64)"
      elseIf (this_type is Program.type_Int64) cast = "(RogueInt64)"
      writer.print( Program.program_name ).print( ".mod( " ).print( cast )
      left.write_cpp( writer )
      writer.print( ", " ).print( cast )
      right.write_cpp( writer )
      writer.print( " )" )
endAugment
}#


augment CmdPower
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( left.type ).print( ") pow((double)")
      left.write_cpp( writer )
      writer.print( ", (double)" )
      right.write_cpp( writer )
      writer.print( "))" )
endAugment


augment CmdLogicalAnd
  METHODS
    method cpp_symbol->String
      return "&&"
endAugment


augment CmdLogicalOr
  METHODS
    method cpp_symbol->String
      return "||"
endAugment


augment CmdLogicalXor
  METHODS
    method cpp_symbol->String
      return "^"
endAugment

augment CmdCompareIs
  METHODS
    method cpp_symbol->String
      return "=="

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((void*)" )
      left.write_cpp( writer )
      writer.print( ") == ((void*)" )
      right.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdCompareIsNot
  METHODS
    method cpp_symbol->String
      return "!="

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((void*)" )
      left.write_cpp( writer )
      writer.print( ") != ((void*)" )
      right.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdBitwiseXor
  METHODS
    method cpp_symbol->String
      return "^"
endAugment

augment CmdBitwiseShiftLeft
  METHODS
    method cpp_symbol->String
      return "<<"
endAugment

#{
augment CmdBitwiseShiftRight
  PROPERTIES

  METHODS
    method cpp_symbol->String
      return ">>>"

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "Rogue_program.shift_right( " )
      left.write_cpp( writer )
      writer.print( ", " )
      right.write_cpp( writer )
      writer.print( " )" )
endAugment
}#

augment CmdBitwiseShiftRightX
  METHODS
    method cpp_symbol->String
      return ">>"
endAugment


augment CmdBitwiseNot
  METHODS
    method cpp_prefix_symbol->String
      return "~"
endAugment

augment CmdAdjustLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )
      writer.print( local_info.cpp_name )
endAugment


augment CmdAdjustProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name )
endAugment


augment CmdAdjustGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )

      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )
      writer.print( global_info.cpp_name )
endAugment


augment CmdResolvedModifyAndAssign
  METHODS
    method cpp_symbol->String
      return symbol
endAugment

augment CmdModifyAndAssignLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name ).print( " " ).print( cpp_symbol ).print( " " )
      new_value.write_cpp( writer )
endAugment


augment CmdModifyAndAssignGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      #writer.print_type_name( global_info.type_context ).print( "::" )
      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.write_cpp( writer )
endAugment

augment CmdModifyAndAssignProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.write_cpp( writer )
endAugment

augment CmdCreateArray
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "RogueType_create_array( " )
      count_cmd.write_cpp( writer )
      writer.print( ", sizeof(" ).print( array_type.element_type ).print( ")" )
      if (array_type.element_type.is_reference) writer.print( ", true" )
      writer.print( " )" )
endAugment

augment CmdReadArrayElement
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local element_type = array_type.element_type
      if (not is_statement) writer.print_open_cast( element_type, element_type )
      if (element_type.is_reference)
        writer.print( "((" )
        writer.print( element_type )
        writer.print( ")(" )
        context.write_cpp( writer )
        writer.print( "->as_objects[" )
        index.write_cpp( writer )
        writer.print( "]))" )

      elseIf (element_type.is_primitive)
        context.write_cpp( writer )
        writer.print( "->" )
        which (element_type)
          case Program.type_Real64:      writer.print( "as_real64s[" )
          case Program.type_Real32:     writer.print( "as_real32s[" )
          case Program.type_Int64:      writer.print( "as_int64s[" )
          case Program.type_Int32:   writer.print( "as_int32s[" )
          case Program.type_Character: writer.print( "as_characters[" )
          case Program.type_Byte:      writer.print( "as_bytes[" )
          case Program.type_Logical:   writer.print( "as_logicals[" )
          others
            throw t.error( "[INTERNAL] Unhandled type in CmdReadArrayElement." )
        endWhich
        index.write_cpp( writer )
        writer.print( "]" )

      else
        # Compound
        writer.print( "((" ).print( element_type ).print( "*)(" )
        context.write_cpp( writer )
        writer.print( "->as_bytes))[" )
        index.write_cpp( writer )
        writer.print( "]" )

      endIf
      if (not is_statement) writer.print_close_cast( element_type, element_type )
endAugment

augment CmdReadArrayCount
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      context.write_cpp( writer )
      writer.print( "->count" )
endAugment

augment CmdWriteArrayElement
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local element_type = array_type.element_type
      if (element_type.is_primitive)
        context.write_cpp( writer )
        writer.print( "->" )
        which (element_type)
          case Program.type_Real64:      writer.print( "as_real64s[" )
          case Program.type_Real32:     writer.print( "as_real32s[" )
          case Program.type_Int64:      writer.print( "as_int64s[" )
          case Program.type_Int32:   writer.print( "as_int32s[" )
          case Program.type_Character: writer.print( "as_characters[" )
          case Program.type_Byte:      writer.print( "as_bytes[" )
          case Program.type_Logical:   writer.print( "as_logicals[" )
        endWhich
        index.write_cpp( writer )
        writer.print( "] = " )
        if (new_value.type is not element_type) writer.print_cast( new_value.type, element_type )
        new_value.write_cpp( writer )

      elseIf (element_type.is_reference)
        context.write_cpp( writer )
        writer.print( "->" )
        writer.print( "as_objects[" )
        index.write_cpp( writer )
        writer.print( "] = " )
        new_value.write_cpp( writer )

      else
        writer.print( "((" ).print( element_type ).print( "*)(" )
        context.write_cpp( writer )
        writer.print( "->as_bytes))[" )
        index.write_cpp( writer )
        writer.print( "] = " )
        new_value.write_cpp( writer )

      endIf
endAugment

augment CmdCastToType
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (is_statement)
        operand.write_cpp( writer )
      else
        writer.print( "((" ).print( target_type ).print( ")(" )
        operand.write_cpp( writer )
        writer.print( "))" )
      endIf
endAugment

augment CmdConvertToPrimitiveType
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( target_type.cpp_class_name ).print( ")(" )
      operand.write_cpp( writer )
      writer.print( "))" )
endAugment

augment CmdAs
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( target_type ).print( ")(RogueObject_as(" )
      operand.write_cpp( writer )
      writer.print( "," )
      writer.print_type_info( target_type )
      writer.print( ")))" )
endAugment

augment CmdInstanceOf
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "RogueObject_instance_of(" )
      operand.write_cpp( writer )
      writer.print( "," )
      writer.print_type_info( target_type )
      writer.print( ")" )
endAugment


augment CmdTaskControl
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "switch (++THIS->ip)" )
      writer.println( "{" )
      writer.indent += 2
      forEach (section in sections)
        writer.print( "case " ).print( section.ip ).println( ":" )
        section.statements.write_cpp( writer )
      endForEach
      writer.println( "default:" )
      writer.println( "  THIS->ip = -1;" )
      writer.println( "  return false;" )
      writer.indent -= 2
      writer.println( "}" )
endAugment


augment CmdCreateOptionalValue
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (of_type.element_type.is_reference)
        # Reference types don't need an intermediate type to signify null
        if (value)
          value.write_cpp( writer )
        else
          writer.print "NULL"
        endIf
      else
        # Non-reference types are kept in Optional<<DataType>> wrappers
        writer.print( of_type )
        if (value)
          writer.print( "( " )
          value.write_cpp( writer )
          writer.print( " )" )
        else
          writer.print( "()" )
        endIf
      endIf

endAugment


augment CmdLabel
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      statements.write_cpp( writer, is_statement )
endAugment

augment CmdInlineNative
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      which (adjust_delta)
        case -1: writer.print( "--" )
        case  1: writer.print( "++" )
      endWhich

      writer.print_native_code( t, this_method.type_context, this_method, local_list, code, result_type )
      if (adjust_delta) writer.println( ";" ); return

      if (code.contains('\n') or not result_type) writer.println
      if (new_value)
        if (modify_op) writer.print(' ').print( modify_op->String ).print(' ')
        else           writer.print( " = " )
        new_value.write_cpp( writer )
        writer.println( ";" )
      endIf
endAugment

augment CmdMakeRequisite
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdNoAction
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdSelect
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      write_cpp( cases.reader, writer, &first_case )

    method write_cpp( reader:ListReader<<CmdSelectCase>>, writer:CPPWriter, &first_case )
      local select_case = reader.read

      if (not reader.has_another)
        # Final value
        if (value_type.is_reference) writer.print("ROGUE_ARG(")
        select_case.value.write_cpp( writer )
        if (value_type.is_reference) writer.print(")")
        return
      endIf

      writer.print( "((" )

      local first_condition = true
      forEach (c in select_case.conditions)
        if (first_condition) first_condition = false
        else                 writer.print " || "

        writer.print "("
        if (expression)
          if (first_case)
            # Need to store expression in local
            writer.print( "(" ).print( local_info.cpp_name ).print( "=" )
            expression.write_cpp( writer )
            writer.print( ")" )
            first_case = false
          else
            writer.print( local_info.cpp_name )
          endIf
          writer.print( "==" )
        endIf

        writer.print( "(" )
        c.write_cpp( writer )
        writer.print( "))" )
      endForEach

      writer.print( ") ? (" )

      if (value_type.is_reference) writer.print("ROGUE_ARG(")
      select_case.value.write_cpp( writer )
      if (value_type.is_reference) writer.print(")")

      writer.print( ") : " )

      write_cpp( reader, writer )

      writer.print ")"
endAugment


augment CmdAssert
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( local_info.cpp_name ).print( "=" )
      writer.print "("
      condition.write_cpp( writer )
      writer.print( "))?" ).print( local_info.cpp_name ).print( ":" )
      error.write_cpp( writer )
      writer.print( ")" )
endAugment


augment CmdRequire
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( local_info.cpp_name ).print( "=" )
      writer.print "("
      condition.write_cpp( writer )
      writer.print( "))?" ).print( local_info.cpp_name ).print( ":" )
      error.write_cpp( writer )
      writer.print( ")" )
endAugment


#{
augment CmdEnsure
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "(" ).print( local_info.cpp_name ).print( "=" )
      cmd_read.write_cpp( writer )
      writer.print( ") ? " ).print( local_info.cpp_name ).print( " : (" )
      cmd_write.write_cpp( writer )
      writer.print( ")" )

endAugment
}#
