$define RELEASE_VERSION "1.0.41.0"
$define RELEASE_DATE    "March 21, 2016"

$include "Attributes.rogue"
$include "CPPWriter.rogue"
$include "CloneArgs.rogue"
$include "Cmd.rogue"
#$include "JavaWriter.rogue"
$include "Local.rogue"
$include "Method.rogue"
$include "Parser.rogue"
$include "Plugin.rogue"
$include "Preprocessor.rogue"
$include "Program.rogue"
$include "Property.rogue"
$include "RogueError.rogue"
$include "Scope.rogue"
$include "Template.rogue"
$include "Token.rogue"
$include "TokenReader.rogue"
$include "TokenType.rogue"
$include "Tokenizer.rogue"
$include "Type.rogue"

RogueC.launch


class GCMode
  ENUMERATE
    MANUAL
    AUTO
    BOEHM
endClass


class RogueC [singleton]
  PROPERTIES
    included_files     = String[]
    prefix_path_list   = String[]
    prefix_path_lookup = Table<<String,Logical>>()
    compile_targets    = Table<<String,Logical>>()
    target_list        = String[]
    libraries_folder   = ""

    source_files    = String[]
    generate_main   : Logical
    first_filepath  : String
    output_filepath : String

    supported_targets      = String[]
    requisite_declarations = String[]

    all_requisite = false
    # If true everything is requisite

    all_methods_callable_dynamically = false
    # When true, all methods can be called dynamically

    execute_args      : String

    package_name      : String

    debug_mode        : Logical
    print_version     : Logical

    parsers = Parser[]
    # One parser is created for every file and all parsers are prepped with tokens
    # before any parser parses its elements.  This allows all tokens to be filtered
    # a final time after tokenization to facilitate 'module' and 'using' directives.

    parsereaders_by_filepath = Table<<String,ParseReader>>()
    stopwatch : Stopwatch

    gc_mode = GCMode.MANUAL  : Int32
    gc_threshold = 1024*1024 : Int32

    plugins = Plugin[]

  METHODS
    method launch
      local libs = File.path(System.executable_filepath) + "/Libraries/"
      if (File.exists(libs))
        libraries_folder = libs
        prefix_path_list.add( libs )
        prefix_path_lookup[ libs ] = true
      endIf

      try
        process_command_line_arguments

        <<collect_supported_targets>>
        forEach (plugin in plugins) plugin.collect_supported_targets

        if (source_files.count == 0)
          if (print_version)
            # Print version and date only and exit
            print( 'v' ).println( RELEASE_VERSION )
            println RELEASE_DATE
            System.exit( 0 )
          endIf

          println
          println "Rogue Compiler v" + RELEASE_VERSION
          println RELEASE_DATE

          local usage =
                  @|
                   |USAGE
                   |  roguec [options] file1.rogue [file2.rogue ...]
                   |
                   |OPTIONS
                   |  --main
                   |    Include a main() function in the output file.
                   |
                   |  --debug
                   |    Enables exception stack traces.
                   |
                   |  --execute[="args"]
                   |    Use command line directives to compile and run the output of the
                   |    compiled .rogue program.  Automatically enables the --main option.
                   |
                   |  --gc[=[manual|auto|boehm]]
                   |    Set the garbage collection mode:
                   |      (no --gc)   - Manual GC mode, the default (see below).
                   |      --gc        - Auto GC mode (see below).
                   |      --gc=manual - Rogue_collect_garbage() must be called in-between calls
                   |                    into the Rogue runtime.
                   |      --gc=auto   - Rogue collects garbage as it executes.  Slower than
                   |                    'manual' without optimizations enabled.
                   |      --gc=boehm  - Uses the Boehm garbage collector.  The Boehm's GC library
                   |                    must be obtained separately and linked in.
                   |
                   |  --gc-threshold={number}[MB|K]
                   |    Specifies the default garbage collection threshold of the compiled program.
                   |    Default is 1MB.  If neither MB nor K is specified then the number is
                   |    assumed to be bytes.
                   |
                   |  --libraries="path1[;path2...]"
                   |    Add one or more additional library folders to the search path.
                   |
                   |  --output=destpath/[filename]
                   |    Specify the destination folder and optionally the base filename for the
                   |    output.
                   |
                   |  --requisite=[ClassName|ClassName.method_name(ParamType1,ParamType2,...)],...
                   |
                   |  --target=

                   # --target info filled in below

                   #|  --package=com.developer.app [Java only]

          usage += supported_targets->String.replacing(',','|').replacing("]",",Mac,Windows,iOS,Android,...]\n")

          usage += @|
                    |  --version
                    |    Print the version number and release date.
          println usage
          System.exit( 1 )
        endIf

        if (target_list.count == 0) target_list.add( "C++" )
        forEach (target in target_list)
          compile_targets[target] = true
        endForEach

        Program.configure

        stopwatch = Stopwatch()

        forEach (filepath in source_files)
          include_source( filepath )
        endForEach
        include_source( "Standard" )

        forEach (parser in parsers) parser.insert_module_prefixes
        forEach (parser in parsers) parser.parse_elements

        # Add requisite declarations to Program's requisite list
        local t = TokenType("Internal").create_token( "[Command Line Arguments]", 0, 0 )
        forEach (declaration in requisite_declarations)
          Program.get_launch_method( t ).statements.add( CmdMakeRequisite(t,declaration) )
        endForEach

        if (all_requisite) Program.all_requisite = true

        Program.resolve

        write_output

      catch (err:Error)
        println err
        System.exit(1)
      endTry

    method write_output
      <<target_specific_code>>
      throw RogueError( ''Compile target "$" is not supported.'' (target_list) )

    method on_compile_finished
      println "SUCCESS ($)" (stopwatch)

    method include_source( filepath:String )
      if (not first_filepath) first_filepath = filepath
      include_source( null, filepath )

    method include_source( t:Token, filepath:String )
      # Preemptively (immediately) parses the given file.
      local file = File(filepath)

      if (File.exists(filepath+".rogue"))
        filepath += ".rogue"
        file = File( filepath )
      endIf

      if (not file.exists)
        forEach (prefix in prefix_path_list)
          local prefixed_filepath = prefix + filepath
          local prefixed_file = File( prefixed_filepath )
          if (File.exists(prefixed_filepath+".rogue"))
            filepath = prefixed_filepath + ".rogue"
            file = File( filepath )
            escapeForEach
          elseIf (prefixed_file.exists)
            filepath = prefixed_filepath
            file = prefixed_file
            escapeForEach
          endIf
        endForEach
      endIf

      if (not file.exists)
        local mesg = ''No such file "$".'' (filepath)
        if (t) throw t.error( mesg )
        else   throw RogueError( mesg )
      endIf

      if (file.is_folder)
        local path2 = "$/$.rogue" (filepath,file.filename)
        local file2 = File( path2 )
        if (not file2.exists or file2.is_folder)
          local mesg = ''Can not find "$" to include.'' (path2)
          if (t) throw t.error( mesg )
          else    throw RogueError( mesg )
        else
          if (not prefix_path_lookup.contains(file.filepath))
            prefix_path_lookup[file.filepath] = true
            prefix_path_list.add( file.filepath )
          endIf
          filepath = path2
          file = file2
        endIf
      endIf

      filepath = file.absolute_filepath
      if (included_files.contains(filepath)) return

      if (included_files.count == 0) Program.first_filepath = filepath

      included_files.add( filepath )

      local prefix = filepath.before_last('/') + "/"
      if (not prefix_path_lookup.contains(prefix))
        prefix_path_lookup[prefix] = true
        prefix_path_list.add( prefix )
      endIf

      parsers.add( Parser( filepath ) )

    method include_native( t:Token, filepath:String, native_type:String )
      local file = File(filepath)

      if (not file.exists)
        forEach (prefix in prefix_path_list)
          local prefixed_filepath = prefix + filepath
          local prefixed_file = File( prefixed_filepath )
          if (prefixed_file.exists)
            filepath = prefixed_filepath
            file = prefixed_file
            escapeForEach
          endIf
        endForEach
      endIf

      if (not file.exists)
        local mesg = ''No such file "$".'' (filepath)
        if (t) throw t.error( mesg )
        else   throw RogueError( mesg )
      endIf

      if (file.is_folder)
        local mesg = ''Cannot target folder "$" for a native include.'' (file.filepath)
        if (t) throw t.error( mesg )
        else   throw RogueError( mesg )
      endIf

      filepath = file.absolute_filepath
      if (included_files.contains(filepath)) return

      included_files.add( filepath )

      local prefix = filepath.before_last('/') + "/"
      if (not prefix_path_lookup.contains(prefix))
        prefix_path_lookup[prefix] = true
        prefix_path_list.add( prefix )
      endIf

      if (native_type == "header")
        forEach (line in LineReader(file))
          Program.native_header.add( line )
        endForEach
      else
        forEach (line in LineReader(file))
          Program.native_code.add( line )
        endForEach
      endIf

    method process_command_line_arguments
      forEach (arg in System.command_line_arguments)
        local value = arg.after_first('=')
        arg = arg.before_first('=')
        if (arg.begins_with("--"))
          # Option
          which (arg)
            case "--output"
              if (value.count == 0) throw RogueError( ''Output filepath expected after "--output=".'' )
              output_filepath = value

            case "--execute"
              generate_main = true
              execute_args = value

            case "--debug"
              debug_mode = true

            case "--libraries"
              if (not value.count) throw RogueError( ''One or more paths expected after "--libraries=".'' )
              forEach (path in value.split(';'))
                if (not File.exists(path))
                  throw RogueError( ''--libraries option specifies non-existent folder "$".'' (path) )
                endIf
                if (File.is_folder(path))
                  if (not path.ends_with('/')) path += '/'
                  if (not prefix_path_lookup.contains(path))
                    prefix_path_list.add( path )
                    prefix_path_lookup[ path ] = true
                  endIf
                else
                  source_files.add( path )
                endIf
              endForEach

            case "--main"
              if (value.count) throw RogueError( "Unexpected value for '--main' option." )
              generate_main = true

            case "--package"
              if (not value.count)
                throw RogueError( ''Java package name expected after "--package=" (e.g. "com.developer.app").'' )
              endIf
              package_name = value

            case "--requisite"
              if (value.count)
                requisite_declarations.add( value.split(',') )
              else
                all_requisite = true
              endIf

            case "--target"
              if (not value.count)
                throw RogueError( ''One or more comma-separated target names expected after "--target=" (e.g. "C++").'' )
              endIf
              target_list.add( value.split(',') )

            case "--gc"
              if ((not value.count) or value == "auto")
                # Default to AUTO if nothing specified
                gc_mode = GCMode.AUTO
              elseIf (value == "manual")
                gc_mode = GCMode.MANUAL
              elseIf (value == "boehm")
                gc_mode = GCMode.BOEHM
              else
                throw RogueError( 'Unknown GC mode (--gc=$)' (value) )
              endIf

            case "--gc-threshold"
              if (not value.count)
                throw RogueError( ''A value such as 1.1MB, 512K, or 65536 expected after "--gc-threshold=".'' )
              endIf
              value = value.to_lowercase
              local n = value->Real64
              if (value.ends_with('m') or value.ends_with("mb")) n *= 1024*1024
              elseIf (value.ends_with('k') or value.ends_with("kb")) n *= 1024
              local thresh = n->Int32
              if (thresh < 1) thresh = 0x7fffffff
              gc_threshold = thresh

            case "--plugin-test"
              plugins.add(
                Plugin( "Test" ).on_generate_additional_types(
                  function->Logical
                  @trace "All types resolved - generate additional types?"
                    if (not Program.find_type("Alpha"))
                      local src = @|class Alpha [requisite singleton]
                                   |  METHODS
                                   |    method init
                                   |      @trace "Alpha singleton instantiated!"
                                   |endClass
                      println "Yes - compiling type Alpha:"
                      println src
                      Parser( "(compiler-generated)", src ).parse_elements
                      return true
                    else
                      println "No"
                      return false
                    endIf
                  endFunction
                )
              )

            case "--version"
              if (value.count)
                throw RogueError( ''Unexpected argument to --version option.'' )
              endIf
              print_version = true

            others
              throw RogueError( "Unknown option '$'." (arg) )

          endWhich
        else
          # Input Filename
          source_files.add( arg )
        endIf
      endForEach

    method require_valueless( arg:String, expecting:String )
      if (arg == expecting) return
      if (arg.contains('=')) throw RogueError( "Unexpected value for command line argument '$'." (expecting) )

endClass

#{
                   |      manual - A GC cannot happen while Rogue-generated code is executing.
                   |               After control returns to C++, the main loop must call either
                   |               Rogue_collect_garbage() or Rogue_update_tasks() which will allow
                   |               the GC to run if it needs to.  Manual execution is typically
                   |               just slightly faster than auto.
                   |
                   |      auto   - Generated code code automatically checks for and performs a GC if
                   |               necessary as it runs and allocates objects.  Generated auto-GC
                   |               code should be compiled with -O3 to make its speed acceptable.
                   |
                   }#
