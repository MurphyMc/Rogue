class Introspector
  GLOBAL METHODS
    method _ret_Object (p:IntPtr)->Value
      return native("*(RogueObject**)$p")->Object
    method _ret_Real64 (p:IntPtr)->Value
      return native("*(RogueReal64*)$p")->Real64
    method _ret_Real32 (p:IntPtr)->Value
      return native("*(RogueReal32*)$p")->Real32
    method _ret_Int64 (p:IntPtr)->Value
      return native("*(RogueInt64*)$p")->Int64
    method _ret_Int32 (p:IntPtr)->Value
      return native("*(RogueInt32*)$p")->Int32
    method _ret_Character (p:IntPtr)->Value
      return native("*(RogueCharacter*)$p")->Character
    method _ret_Byte (p:IntPtr)->Value
      return native("*(RogueByte*)$p")->Byte
    method _ret_String (p:IntPtr)->Value
      return native("*(RogueString**)$p")->String
    method _ret_Logical (p:IntPtr)->Value
      return native("*(RogueLogical*)$p")->Logical
    method _ret_undefined (p:IntPtr)->Value
      return UndefinedValue

  PROPERTIES
    context : Object
    address : IntPtr
    info    : TypeInfo

  METHODS
    method init( context )
      address = native( "((intptr_t)$context)" )->IntPtr
      info = context.type_info

    method init( context, address, info )

    method get( name:String )->Value
      local property_info = info.property_info( name )
      if (not property_info) return NullValue

      if (property_info.type.is_reference)
        return Value( native( "*((RogueObject**)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Object )
      endIf

      which (property_info.type.name)
        case "Real64"
          return Value( native( "*((RogueReal64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Real64 )

        case "Real32"
          return Value( native( "*((RogueReal32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Real32 )

        case "Int64"
          return Value( native( "*((RogueInt64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Int64->Real64 )

        case "Int32"
          return Value( native( "*((RogueInt32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Int32 )

        case "Character"
          return Value( native( "*((RogueCharacter*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Character + "" )

        case "Byte"
          return Value( native( "*((RogueByte*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Byte )

        case "Logical"
          return Value( native( "*((RogueLogical*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Logical )

        others
          # Must be a compound
          return Introspector( context, native( "(RogueInt64)(intptr_t)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])" )->Int64, property_info.type )->Value
      endWhich

    method set( name:String, new_value:Value )->this
      local property_info = info.property_info( name )
      if (not property_info) return this

      if (property_info.type.is_reference)
        local value = new_value->Object
        native( "*((RogueObject**)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )
        return this
      endIf

      which (property_info.type.name)
        case "Real64"
          local value = new_value->Real64
          native( "*((RogueReal64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Real32"
          local value = new_value->Real32
          native( "*((RogueReal32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Int64"
          local value = new_value->Int64
          native( "*((RogueInt64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Int32"
          local value = new_value->Int32
          native( "*((RogueInt32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Character"
          local value = new_value->Character
          native( "*((RogueCharacter*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Byte"
          local value = new_value->Byte
          native( "*((RogueByte*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Logical"
          local value = new_value->Logical
          native( "*((RogueLogical*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        others
          # Must be a compound
          Introspector( context, native( "(RogueInt64)(intptr_t)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])" )->Int64, property_info.type ).set( new_value )
      endWhich

      return this

    method set( new_value:Value )->this
      if (new_value.is_table)
        forEach (key in (new_value as ValueTable).keys)
          set( key, new_value[key] )
        endForEach
        return this
      endIf

      if (info.is_reference)
        native( "*(RogueObject**)((RogueByte*)(intptr_t)$address)" )->Object = new_value->Object
        return this
      endIf

      which (info.name)
        case "Real64"
          native( "*(RogueReal64*)((RogueByte*)(intptr_t)$address)" )->Real64 = new_value->Real64

        case "Real32"
          native( "*(RogueReal32*)((RogueByte*)(intptr_t)$address)" )->Real32 = new_value->Real32

        case "Int64"
          native( "*(RogueInt64*)((RogueByte*)(intptr_t)$address)" )->Int64 = new_value->Int64

        case "Int32"
          native( "*(RogueInt32*)((RogueByte*)(intptr_t)$address)" )->Int32 = new_value->Int32

        case "Character"
          native( "*(RogueCharacter*)((RogueByte*)(intptr_t)$address)" )->Character = new_value->Character

        case "Byte"
          native( "*(RogueByte*)((RogueByte*)(intptr_t)$address)" )->Byte = new_value->Byte

        case "Logical"
          native( "*(RogueLogical*)((RogueByte*)(intptr_t)$address)" )->Logical = new_value->Logical

      endWhich

      return this

    method to->String
      return this->Value->String

    method to->Value
      local result = @{}
      forEach (p in info.properties)
        result[ p.name ] = this[ p.name ]
      endForEach
      return result

    method call ( name:String, args:ValueList )->Value
      return call(name, args.data)

    method call ( name:String, args:Value[] )->Value
      local methods = context.type_info.method_info( name )
      #TODO: We can do better method selection than this, but for now, we go simple:
      #      pick the first one with the matching number of parameters.  If we end
      #      up not being able to convert an argument, we try the next one.
      #local msgs = String[]
      forEach (m in methods)
        if (m.param_count == args.count)
          try
            return call(m, args)
          catch (ex : NoMatchingMethodError)
            noAction # Try the next one
            #msgs.add(ex.message)
          endTry
        endIf
      endForEach
      #println msgs
      throw Error("No matching method '$' ($ candidate(s))" (name, methods.count))

    method call ( m:MethodInfo, args:Value[] )->Value
      nativeHeader
        #include <ffi.h>
      endNativeHeader

      assert m.param_count == args.count
      local build = true
      local r_buf_ptr : IntPtr
      native @|ffi_cif cif;
              |ffi_type ** types = (ffi_type **)alloca(sizeof(ffi_type *) * ($args->count + 1));
              |ffi_type ** next_type = types;
              |void ** cargs = (void **)alloca(sizeof(void *) * ($args->count + 1));
              |void ** next_carg = cargs;
              |#define ROGUE_ARG_PUSH(_t,_f,_v) { \
              |  _t * tmp = (_t *) alloca( sizeof(_t) ); \
              |  *tmp = _v; \
              |  *(next_carg++) = tmp; \
              |  if ($build) *(next_type++) = &_f; \
              |}
              |char r_buf[16]; // Return buffer, must be large enough for largest type
              |$r_buf_ptr = (intptr_t)(void *)r_buf;

      native "ROGUE_ARG_PUSH(RogueObject*, ffi_type_pointer, $this->context);"

      forEach (p at index in m.param_types)
        local a = args[index]
        which (p.name)
          case "String"
            _check_param(index, p, a.is_string)
            block
              local c = a->String
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_pointer, $c);"
            endBlock
            nextIteration

          case "Real64"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real64
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_double, $c);"
            endBlock
            nextIteration
          case "Real32"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real32
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_float, $c);"
            endBlock
            nextIteration
          case "Int64"
            #_check_param(index, p, a.is_int64 or a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int64
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint64, $c);"
            endBlock
            nextIteration
          case "Int32"
            #_check_param(index, p, a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int32
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint32, $c);"
            endBlock
            nextIteration
          case "Character"
            #_check_param(index, p, a.is_character)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Character
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint32, $c);"
            endBlock
            nextIteration
          case "Byte"
            #_check_param(index, p, a.is_byte)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Byte
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_uint8, $c);"
            endBlock
            nextIteration
          case "Logical"
            _check_param(index, p, a.is_logical)
            block
              local c = a->Logical
              native @|static_assert(sizeof($c) == 4 || sizeof($c) == 8 || sizeof($c) == 1, "Logicals are of unhandled size on this platform");
                      |if (sizeof($c) == 4) {
                      |  int32_t cc = (int32_t)$c;
                      |  ROGUE_ARG_PUSH(int32_t, ffi_type_sint32, cc);
                      |} else if (sizeof($c) == 8) {
                      |  int64_t cc = (int64_t)$c;
                      |  ROGUE_ARG_PUSH(int64_t, ffi_type_sint32, cc);
                      |} else {
                      |  int8_t cc = (int8_t)$c;
                      |  ROGUE_ARG_PUSH(int8_t, ffi_type_sint8, cc);
                      |}
            endBlock
            nextIteration
          others
            if (p.is_reference)
              _check_param(index, p, a.is_object)
              local c = a->Object
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_pointer, $c);"
              nextIteration
            endIf
        endWhich

        throw NoMatchingMethodError("Argument $ is of unhandled type $" (index+1, p.name))
      endForEach

      native "#undef ROGUE_ARG_PUSH"
      native "ffi_type * ret_type = &ffi_type_void;"

      local rt = m.return_type
      local ret_func = this=>_ret_undefined : Function(IntPtr)->(Value)
      block
        if (rt is null)
          escapeBlock
        endIf

        which (rt.name)
          case "Real64"
            native "ret_type = &ffi_type_double;"
            ret_func = this=>_ret_Real64
          case "Real32"
            native "ret_type = &ffi_type_float;"
            ret_func = this=>_ret_Real32
          case "Int64"
            native "ret_type = &ffi_type_sint64;"
            ret_func = this=>_ret_Int64
          case "Int32"
            native "ret_type = &ffi_type_sint32;"
            ret_func = this=>_ret_Int32
          case "Character"
            native "ret_type = &ffi_type_sint32;"
            ret_func = this=>_ret_Character
          case "Byte"
            native "ret_type = &ffi_type_uint8;"
            ret_func = this=>_ret_Byte
          case "Logical"
            block
              local c : Logical
              native @|static_assert(sizeof($c) == 4 || sizeof($c) == 8 || sizeof($c) == 1, "Logicals are of unhandled size on this platform");
                      |if (sizeof($c) == 4) {
                      |  ret_type = &ffi_type_sint32;
                      |} else if (sizeof($c) == 8) {
                      |  ret_type = &ffi_type_sint64;
                      |} else {
                      |  ret_type = &ffi_type_sint8;
                      |}
            endBlock
            ret_func = this=>_ret_Logical
          case "String"
            native "ret_type = &ffi_type_pointer;"
            ret_func = this=>_ret_String
          others
            if (rt.is_reference)
              native "ret_type = &ffi_type_pointer;"
              ret_func = this=>_ret_Object
              escapeBlock
            endIf
            throw NoMatchingMethodError("Return type is of unhandled type $" (rt.name))
        endWhich
      endBlock

      local failed = false
      native @|ffi_status s = ffi_prep_cif(&cif, FFI_DEFAULT_ABI, $args->count + 1, ret_type, types);
              |if (s != FFI_OK) $failed = 1;
      if (failed) throw NoMatchingMethodError("CIF creation failed")

      # Should (or can) we cache the cif?
      local fn_ptr = m.fn_ptr

      native "ffi_call (&cif, (void(*)())$fn_ptr, r_buf, cargs);"
      return ret_func(r_buf_ptr)

  method _check_param (index:Int32, ptype:TypeInfo, condition:Logical)
    if (not condition)
      throw NoMatchingMethodError("Argument $ is incompatible with paramter type $" (index+1, ptype))
    endIf
endClass


class ValueTypeIntrospector<<$ValueType>> : Introspector
  PROPERTIES
    value_context : $ValueType

  METHODS
    method init( value_context )
      address = native( "(RogueInt64)(intptr_t)&$value_context" )->Int64
      info = value_context.type_info

    method to->Value
      if (info.is_compound) return prior.to_Value
      else                  return Value( value_context )
endClass


class CompoundIntrospection<<$ValueType>> [aspect]
  METHODS
    method get_property( name:String )->Value [nonAPI]
      return introspector[ name ]

    method get_property<<$PropertyType>>( name:String )->$PropertyType
      forEach (i in 0..<property_count)
        if (property_name(i) == name)
          local type_index = this.type_info.index
          return native( "*(($($PropertyType)*)(((RogueByte*)&$this) + Rogue_types[$type_index].property_offsets[$i]))" )->$PropertyType
        endIf
      endForEach

      local default_value : $PropertyType
      return default_value

    method introspector->Introspector
      return ValueTypeIntrospector<<$ValueType>>( this )

    method property_count->Int32
      return type_info.properties.count

    method property_name( index:Int32 )->String
      return type_info.properties[ index ].name

    method set_property( name:String, value:Value )->this [nonAPI]
      introspector.set( name, value )
      return this

    method set_property<<$PropertyType>>( name:String, value:$PropertyType )->this
      forEach (i in 0..<property_count)
        if (property_name(i) == name)
          local type_index = this.type_info.index
          native( "*(($($PropertyType)*)(((RogueByte*)&$this) + Rogue_types[$type_index].property_offsets[$i])) = $value;" )
          return this
        endIf
      endForEach

      return this

    method to->Value
      return introspector->Value
endClass


class NoMatchingMethodError : Exception
endClass
